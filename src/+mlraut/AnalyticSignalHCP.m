classdef AnalyticSignalHCP < handle & mlraut.AnalyticSignal
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties (Dependent)
        num_nets
        num_sub
        num_tasks

        comparator
        HCP_signals
    end

    methods %% GET, SET
        function g = get.num_nets(~)
            g = length(mlraut.NetworkData.NETWORKS_YEO_NAMES);
        end
        function g = get.num_sub(this)
            g = numel(this.subjects);
        end
        function g = get.num_tasks(this)
            g = numel(this.tasks);
        end

        function g = get.comparator(this)
            g = this.comparator_;
        end
        function g = get.HCP_signals(this)
            g = this.HCP_signals_;
        end
    end
    
    methods
        function psis = average_network_signals(this)
            arguments
                this mlraut.AnalyticSignalHCP
            end

            this.HCP_signals_.cbm.psi = this.average_network_signal(this.bold_signal_, network_type="cerebellar");
            this.HCP_signals_.cbm.phi = this.average_network_signal(this.physio_signal_, network_type="cerebellar");
            this.HCP_signals_.ctx.psi = this.average_network_signal(this.bold_signal_, network_type="cortical");
            this.HCP_signals_.ctx.phi = this.average_network_signal(this.physio_signal_, network_type="cortical");
            this.HCP_signals_.str.psi = this.average_network_signal(this.bold_signal_, network_type="striatal");
            this.HCP_signals_.str.phi = this.average_network_signal(this.physio_signal_, network_type="striatal");
            this.HCP_signals_.thal.psi = this.average_network_signal(this.bold_signal_, network_type="thalamic");
            this.HCP_signals_.thal.phi = this.average_network_signal(this.physio_signal_, network_type="thalamic");
            psis = this.HCP_signals;
        end

        function this = call(this, opts)
            %% CALL only one subject to avoid problems with caching this.roi

            arguments
                this mlraut.AnalyticSignalHCP
                opts.do_qc logical = false
            end

            % exclude subjects
            this.subjects = this.subjects(~contains(this.subjects, '_7T'));  % 7T studies still listed under tasks
            %this.subjects = this.subjects(~contains(this.subjects, 'sub-'));

            out_dir_ = this.out_dir;
            s = 1;
            try
                this.current_subject = this.subjects{s};
                if ~contains(out_dir_, this.current_subject)
                    proposed_dir = fullfile(out_dir_, this.current_subject);
                    this.out_dir = proposed_dir;
                    ensuredir(proposed_dir);
                end
                this.call_subject();
            catch ME
                handexcept(ME)
            end
        end

        function this = call_subject(this)

            %% Hilbert transform is applied after most other operations

            arguments
                this %  mlraut.AnalyticSignalHCP; avoid down-casting
            end

            for t = 1:this.num_tasks     
                try
                    this.malloc();
                    this.current_task = this.tasks{t};

                    % BOLD
                    try
                        bold_gsr_ = ...
                            this.build_global_signal_regressed(this.task_dtseries());
                        bold_ = ...
                            this.build_rescaled( ...
                            this.build_band_passed( ...
                            this.build_centered(bold_gsr_)));
                        if ~isemptytext(getenv("VERBOSITY")); fprintf("size(bold_):\n"); disp(size(bold_)); end
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' BOLD missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % physio
                    try
                        [physio_,physio__] = this.task_physio(size_reference=size(bold_));
                        if ~isemptytext(getenv("VERBOSITY")); fprintf("size(physio_):\n"); disp(size(physio_)); end
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' physio missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % Store BOLD signals
                    this.bold_signal_ = hilbert(bold_);

                    % Store physio signals
                    this.physio_signal_ = hilbert(physio_);

                    % Store averages for networks
                    this.average_network_signals();

                    % Store connectivity for comparisons
                    this.comparator_ = this.connectivity(bold_, physio__);

                    % do save
                    this.meta_save();

                    % do plots
                    this.meta_plot();
                catch ME
                    handwarning(ME)
                end
            end
        end 

        function call_superposition(this, physio_keys, physio_vs, weights)

            %% create and write superposition of results from listed physios

            arguments
                this %  mlraut.AnalyticSignalHCP
                physio_keys string {mustBeText}
                physio_vs double = [this.v_physio_iFV, this.v_physio]
                weights double = [0.5, 0.5]
            end
            assert(length(physio_keys) == 2)
            assert(length(physio_vs) == 2)
            assert(length(weights) == 2)

            for t = 1:this.num_tasks     
                try

                    fqfn1 = this.mat_fqfn( ...
                        v_physio=physio_vs(1), source_physio=physio_keys(1), is_subset=this.do_save_subset);
                    ld1 = load(fqfn1);
                    this1 = ld1.this;

                    fqfn2 = this.mat_fqfn( ...
                        v_physio=physio_vs(2), source_physio=physio_keys(2), is_subset=this.do_save_subset);
                    ld2 = load(fqfn2);
                    this2 = ld2.this;

                    %% modify this1 only

                    this1.current_subject = this.current_subject;
                    this1.current_task = this.tasks{t};

                    this1.source_physio = strrep( ...
                        sprintf("%s%g-%s%g", ...
                        this1.source_physio, weights(1), this2.source_physio, weights(2)), ...
                        ".", "p");

                    % Update BOLD signals
                    this1.bold_signal_ = weights(1)*this1.bold_signal_ + weights(2)*this2.bold_signal_;

                    % Update physio signals
                    this1.physio_signal_ = weights(1)*this1.physio_signal_ + weights(2)*this2.physio_signal_;

                    % Update averages for networks
                    this1.average_network_signals(this1.bold_signal_, this1.physio_signal_);

                    % Null connectivity to avoid saving it
                    this1.comparator_ = [];

                    % do save
                    this1.meta_save();

                    % do plot
                    this1.meta_plot();
                catch ME
                    handwarning(ME)
                end
            end
        end

        function mat = connectivity(~, bold, seed)
            bold = real(bold)';  % Nx x Nt
            seed = real(seed)';  % 1 x Nt
            Nx = size(bold, 1);
            mat = nan(Nx, 1);  % Nx x 1
            for pos = 1:Nx
                R = corrcoef(bold(pos, :), seed);
                mat(pos) = R(1, 2);
            end
        end

        function obj = identity(~, obj)
        end

        function this = malloc(this)

            % accumulate for statistics on serialized AnalyticSignalHCP
            this.bold_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest
            this.physio_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest       

            this.HCP_signals_.cbm.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.cbm.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.phi = complex(nan(this.num_frames,this.num_nets));
        end 

        function meta_plot(this)
            if this.do_plot_global_physio
                error("mlraut:NotImplementedError", stackstr())
            end
            if this.do_plot_wavelets
                this.plot_regions(@this.plot_cmor, measure=@this.X);
                this.plot_regions(@this.plot_cmor, measure=@this.Y);
                this.plot_regions(@this.plot_cmor, measure=@this.Z);
                this.plot_regions(@this.plot_cmor, measure=@this.T);
                this.plot_regions(@this.plot_wcoherence, measure=@nan);
                this.plot_regions(@this.plot_cwt, measure=@nan);
            end
            if this.do_plot_networks
                this.plot_regions(@this.plot_networks, measure=@this.X);
                this.plot_regions(@this.plot_networks, measure=@this.Y);
                this.plot_regions(@this.plot_networks, measure=@this.Z);
                this.plot_regions(@this.plot_networks, measure=@this.T);
                this.plot_regions(@this.plot_networks_dots, measure=@this.angle);
                this.plot_regions(@this.plot_networks_dots, measure=@this.unwrap);
            end
            if this.do_plot_radar
                error("mlraut:NotImplementedError", stackstr())
            end
            if this.do_plot_emd
                error("mlraut:NotImplementedError", stackstr())
            end
        end

        function meta_save(this)
            if this.do_save
                % Store reduced analytic signals for current_subject, current_task
                % grid of data from s, t may be assessed with stats
                save(this);
            end
            if this.do_save_ciftis

                % connectivity(this.bold_signal_, this.physio_signal_), with matching normalizations
                if ~isempty(this.comparator_)
                    this.write_cifti( ...
                        this.comparator_, ...
                        sprintf('connectivity_sub-%s_ses-%s_%s', this.current_subject, this.current_task, this.tags));
                end

                % cortical X(psi, phi) >= 0, region 9 ~ task-, biased but informative
                % parts = this.X(this.HCP_signals.ctx.psi(:,9), this.HCP_signals.ctx.phi(:,9)) >= 0;  
                % parts = cos(this.physio_angle) >= 0;  % unbiased, but shows identical features in trues/falses
                
                for rsn = 1:7
                    angle_rsn = this.angle(this.HCP_signals.ctx.psi(:,rsn), this.HCP_signals.ctx.phi(:,rsn));
                    t_interesting = cos(angle_rsn) > 0;
                    tags = this.tags("rsn"+rsn);
                    this.write_ciftis( ...
                        this.X(this.bold_signal_, this.physio_signal_), ...
                        sprintf('X_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                        partitions=t_interesting, ...
                        do_save_dynamic=this.do_save_dynamic);
                    this.write_ciftis( ...
                        this.Y(this.bold_signal_, this.physio_signal_), ...
                        sprintf('Y_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                        partitions=t_interesting, ...
                        do_save_dynamic=this.do_save_dynamic);
                end  

                this.write_ciftis( ...
                    this.T(this.bold_signal_, this.physio_signal_), ...
                    sprintf('T_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                    partitions=[], ...
                    do_save_dynamic=this.do_save_dynamic);
                this.write_ciftis( ...
                    this.Z(this.bold_signal_, this.physio_signal_), ...
                    sprintf('Z_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                    partitions=[], ...
                    do_save_dynamic=this.do_save_dynamic);
                % this.write_ciftis( ...
                %     this.X(this.bold_signal_, this.physio_signal_), ...
                %     sprintf('X_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                %     partitions=[], ...
                %     do_save_dynamic=this.do_save_dynamic);
                % this.write_ciftis( ...
                %     this.Y(this.bold_signal_, this.physio_signal_), ...
                %     sprintf('Y_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                %     partitions=[], ...
                %     do_save_dynamic=this.do_save_dynamic);
                this.write_ciftis( ...
                    this.angle(this.bold_signal_, this.physio_signal_), ...
                    sprintf('angle_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                    partitions=[], ...
                    do_save_dynamic=this.do_save_dynamic);
                this.write_ciftis( ...
                    this.unwrap(this.bold_signal_, this.physio_signal_), ...
                    sprintf('unwrap_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, tags), ...
                    partitions=[], ...
                    do_save_dynamic=this.do_save_dynamic);
            end
            if this.do_save_ciftis_of_diffs                        
                error("mlraut:NotImplementedError", stackstr())
            end
        end

        function save(this)
            if this.do_save_subset
                this.save_subset();
                return
            end
            try
                save(this.mat_fqfn(), 'this', '-v7.3');
            catch ME
                handwarning(ME)
            end
        end

        function save_subset(this)

            %% reduce size of saved

            this_subset.digital_filter = this.digital_filter;
            this_subset.do_7T = this.do_7T;
            this_subset.do_resting = this.do_resting;
            this_subset.do_task = this.do_task;
            this_subset.do_save = this.do_save;
            this_subset.do_save_ciftis = this.do_save_ciftis;
            this_subset.do_save_ciftis_of_diffs = this.do_save_ciftis_of_diffs;
            this_subset.do_save_dynamic = this.do_save_dynamic;
            this_subset.force_band = this.force_band;
            this_subset.final_normalization = this.final_normalization;
            this_subset.roi = this.roi;
            this_subset.source_physio = this.source_physio;
            this_subset.global_signal = this.global_signal;
            this_subset.global_signal_regression = this.global_signal_regression;
            this_subset.hp_thresh = this.hp_thresh;
            this_subset.lp_thresh = this.lp_thresh;
            this_subset.num_nets = this.num_nets;
            this_subset.num_sub = this.num_sub;
            this_subset.num_tasks = this.num_tasks;
            this_subset.scale_to_hcp = this.scale_to_hcp;
            this_subset.tags = this.tags;
            this_subset.bold_signal = this.bold_signal;
            this_subset.HCP_signals = this.HCP_signals;
            this_subset.physio_signal = this.physio_signal;
            this_subset.comparator = this.comparator;
            this_subset.max_frames = this.max_frames;
            this_subset.current_subject = this.current_subject;
            this_subset.current_task = this.current_task;
            this_subset.subjects = this.subjects;
            this_subset.tasks = this.tasks;
            % this_subset.bold_data = this.bold_data;
            % this_subset.cohort_data = this.cohort_data;
            % this_subset.cifti_last = this.cifti_last;
            this_subset.Fs = this.Fs;
            this_subset.num_frames = this.num_frames;
            this_subset.num_frames_ori = this.num_frames_ori;
            this_subset.num_frames_to_trim = this.num_frames_to_trim;
            this_subset.num_nodes = this.num_nodes;
            this_subset.out_dir = this.out_dir;
            this_subset.root_dir = this.root_dir;
            this_subset.task_dir = this.task_dir;
            this_subset.task_dtseries_fqfn = this.task_dtseries_fqfn;
            this_subset.task_niigz_fqfn = this.task_niigz_fqfn;
            this_subset.task_signal_reference_fqfn = this.task_signal_reference_fqfn;
            this_subset.t1w_fqfn = this.t1w_fqfn;
            this_subset.tr = this.tr;
            this_subset.waves_dir = this.waves_dir;
            this_subset.wmparc_fqfn = this.wmparc_fqfn;
            this_subset.workbench_dir = this.workbench_dir;
            try
                save(this.mat_fqfn(is_subset=true), 'this_subset', '-v7.3');
            catch ME
                handwarning(ME)
            end
        end

        function this = AnalyticSignalHCP(varargin)
            this = this@mlraut.AnalyticSignal(varargin{:});
        end
    end

    %% PROTECTED

    properties (Access = protected)
        comparator_
        HCP_signals_
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
