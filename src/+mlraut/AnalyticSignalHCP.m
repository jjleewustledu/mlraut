classdef AnalyticSignalHCP < handle & mlraut.AnalyticSignal
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties (Dependent)
        num_nets
        num_sub
        num_tasks

        analytic_signal
        HCP_signals
    end

    methods %% GET, SET
        function g = get.num_nets(this)
            g = length(mlraut.NetworkData.NETWORKS_YEO_NAMES);
        end
        function g = get.num_sub(this)
            g = numel(this.subjects);
        end
        function g = get.num_tasks(this)
            g = numel(this.tasks);
        end

        function g = get.analytic_signal(this)
            g = this.analytic_signal_;
        end
        function g = get.HCP_signals(this)
            g = this.HCP_signals_;
        end
    end
    
    methods
        function psis = average_network_signals(this, psi)
            arguments
                this mlraut.AnalyticSignalHCP
                psi {mustBeNumeric}
            end

            this.HCP_signals_.cbm = this.average_network_signal(psi, network_type="cerebellar");
            this.HCP_signals_.ctx = this.average_network_signal(psi, network_type="cortical");
            this.HCP_signals_.str = this.average_network_signal(psi, network_type="striatal");
            this.HCP_signals_.thal = this.average_network_signal(psi, network_type="thalamic");
            psis = this.HCP_signals;
        end
        
        function as = build_final_normalization(this, as)
            %% provides final normalization by max(abs()) for more interpretable visualization at group level;
            %  as ~ Nt x Nxyz

            switch convertStringsToChars(this.final_normalization)
                case 'normt'
                    % allowing fluctuations in xyz
                    as = as ./ max(abs(as), [], 1);
                case 'normxyz'
                    % allowing fluctuations in t
                    as = as ./ max(abs(as), [], 2);
                case 'normxyzt'
                    % allowing fluctuations in xyz & t
                    as = as / max(abs(as), [], "all");
                otherwise
                    return
            end
        end

        function this = call(this, opts)
            %% CALL all subjects

            arguments
                this mlraut.AnalyticSignalHCP
                opts.do_qc logical = false
            end

            % exclude subjects
            this.subjects = this.subjects(~contains(this.subjects, '_7T'));
            %this.subjects = this.subjects(~contains(this.subjects, 'sub-'));

            out_dir_ = this.out_dir;
            for s = 1:this.num_sub
                try
                    this.current_subject = this.subjects{s};
                    if ~contains(out_dir_, this.current_subject)
                        proposed_dir = fullfile(out_dir_, this.current_subject);
                        this.out_dir = proposed_dir;
                        ensuredir(proposed_dir);
                    end
                    this.call_subject(s);
                catch ME
                    handexcept(ME)
                end
            end
        end

        function this = call_subject(this, s)

            %% Hilbert transform is applied after most other operations

            arguments
                this mlraut.AnalyticSignalHCP
                s double
            end

            for t = 1:this.num_tasks     
                try
                    this.malloc();
                    this.current_task = this.tasks{t};

                    % BOLD
                    try
                        bold_gsr_ = ...
                            this.build_global_signal_regressed(this.task_dtseries());
                        bold_ = ...
                            this.build_band_passed( ...
                            this.build_centered_and_rescaled(bold_gsr_));
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' BOLD missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % physio
                    try
                        physio_ = ...
                            this.build_band_passed( ...
                            this.build_centered_and_rescaled( ...
                            this.build_global_signal_regressed( ...
                                this.task_physio(reference=bold_gsr_)), reference=bold_gsr_));
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' physio missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % Store BOLD signals
                    this.bold_signal_ = ...
                        this.build_final_normalization( ...
                        hilbert(bold_));

                    % Store physio signals
                    this.physio_signal_ = ...
                        this.build_final_normalization( ...
                        hilbert(physio_));

                    % Store analytic signals
                    this.analytic_signal_ = ...
                        this.build_final_normalization( ...
                            hilbert(physio_)./hilbert(bold_));

                    % Averages for networks
                    this.average_network_signals(this.analytic_signal_);

                    % Store reduced analytic signal, real(), imag(), abs(), angle()
                    if this.do_save
                        % Store reduced analytic signals for all s, t
                        % grid of data from s, t may be assessed with stats
                        save(this, s, t);
                    end
                    if this.do_save_ciftis
                        this.write_ciftis( ...
                            abs(this.analytic_signal_), ...
                            sprintf('abs_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            angle(this.analytic_signal_), ...
                            sprintf('angle_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            do_save_dynamic=this.do_save_dynamic);

                        % connectivity(this.bold_signal_, this.physio_signal_), with matching normalizations
                        this.write_cifti( ...
                            this.connectivity(this.bold_signal_, this.physio_signal_), ...
                            sprintf('connectivity_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags));
                    end
                    if this.do_save_ciftis_of_diffs  % analytic_signal_ - bold_signal_
                        diff_ = this.analytic_signal_ - this.bold_signal_;
                        this.write_ciftis( ...
                            abs(diff_), ...
                            sprintf('abs_diff_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            angle(diff_), ...
                            sprintf('angle_diff_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            do_save_dynamic=this.do_save_dynamic);
                    end

                    % do plot
                    if this.do_plot_global_physio
                        this.plot_global_physio(measure=@this.unwrap);
                        this.plot_global_physio(measure=@angle);
                        this.plot_global_physio(measure=@abs);
                        this.plot_global_physio(measure=@real);
                    end
                    if this.do_plot_networks
                        this.plot_regions(@this.plot_networks, measure=@this.unwrap);
                        this.plot_regions(@this.plot_networks, measure=@angle);
                        this.plot_regions(@this.plot_networks, measure=@abs);
                        this.plot_regions(@this.plot_networks, measure=@real);
                    end
                    if this.do_plot_radar
                        this.plot_regions(@this.plot_radar, measure=@this.identity);
                    end
                    if this.do_plot_emd
                        this.plot_regions(@this.plot_emd, measure=@this.unwrap);
                        this.plot_regions(@this.plot_emd, measure=@angle);
                        this.plot_regions(@this.plot_emd, measure=@abs);
                    end
                catch ME
                    handwarning(ME)
                end
            end
        end  

        function mat = connectivity(~, bold, seed)
            bold = real(bold)';  % Nx x Nt
            seed = real(seed)';  % 1 x Nt
            Nx = size(bold, 1);
            mat = nan(Nx, 1);  % Nx x 1
            for pos = 1:Nx
                R = corrcoef(bold(pos, :), seed);
                mat(pos) = R(1, 2);
            end
        end

        function obj = identity(~, obj)
        end

        function this = malloc(this)

            % accumulate for statistics on serialized AnalyticSignalHCP
            this.bold_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest
            this.physio_signal_ = complex(nan(this.num_frames, 1));              
            this.analytic_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest

            this.HCP_signals_.cbm = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal = complex(nan(this.num_frames,this.num_nets));
        end

        function save(this, s, t)

            % reduce size of saved        
            this_subset.do_7T = this.do_7T;
            this_subset.do_resting = this.do_resting;
            this_subset.do_task = this.do_task;
            this_subset.do_save = this.do_save;
            this_subset.do_save_ciftis = this.do_save_ciftis;
            this_subset.do_save_ciftis_of_diffs = this.do_save_ciftis_of_diffs;
            this_subset.do_save_dynamic = this.do_save_dynamic;
            this_subset.force_band = this.force_band;
            this_subset.final_normalization = this.final_normalization;
            this_subset.roi = this.roi;
            this_subset.source_physio = this.source_physio;
            this_subset.global_signal = this.global_signal;
            this_subset.global_signal_regression = this.global_signal_regression;
            this_subset.hp_thresh = this.hp_thresh;
            this_subset.lp_thresh = this.lp_thresh;
            this_subset.num_nets = this.num_nets;
            this_subset.num_sub = this.num_sub;
            this_subset.num_tasks = this.num_tasks;
            this_subset.scale_to_hcp = this.scale_to_hcp;
            this_subset.tags = this.tags;
            this_subset.analytic_signal = this.analytic_signal;
            % this_subset.bold_signal = this.bold_signal;
            this_subset.HCP_signals = this.HCP_signals;
            this_subset.physio_signal = this.physio_signal;
            this_subset.max_frames = this.max_frames;
            this_subset.current_subject = this.current_subject;
            this_subset.current_task = this.current_task;
            this_subset.subjects = this.subjects;
            this_subset.tasks = this.tasks;
            % this_subset.bold_data = this.bold_data;
            % this_subset.cohort_data = this.cohort_data;
            % this_subset.cifti_last = this.cifti_last;
            this_subset.Fs = this.Fs;
            this_subset.num_frames = this.num_frames;
            this_subset.num_frames_ori = this.num_frames_ori;
            this_subset.num_frames_to_trim = this.num_frames_to_trim;
            this_subset.num_nodes = this.num_nodes;
            this_subset.out_dir = this.out_dir;
            this_subset.root_dir = this.root_dir;
            this_subset.task_dir = this.task_dir;
            this_subset.task_dtseries_fqfn = this.task_dtseries_fqfn;
            this_subset.task_niigz_fqfn = this.task_niigz_fqfn;
            this_subset.task_signal_reference_fqfn = this.task_signal_reference_fqfn;
            this_subset.t1w_fqfn = this.t1w_fqfn;
            this_subset.tr = this.tr;
            this_subset.waves_dir = this.waves_dir;
            this_subset.wmparc_fqfn = this.wmparc_fqfn;
            this_subset.workbench_dir = this.workbench_dir;
            
            try
                save(fullfile(this.out_dir, ...
                    sprintf("sub-%s_ses-%s_%s.mat", this.subjects{s}, strrep(this.tasks{t}, "_", "-"), this.tags)), ...
                    'this_subset');
            catch ME
                handwarning(ME)
            end
        end

        function this = AnalyticSignalHCP(varargin)
            this = this@mlraut.AnalyticSignal(varargin{:});
        end
    end

    %% PROTECTED

    properties (Access = protected)
        analytic_signal_
        HCP_signals_
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
