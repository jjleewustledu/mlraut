classdef AnalyticSignalHCP < handle & mlraut.AnalyticSignal
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties (Dependent)
        num_nets
        num_sub
        num_tasks

        comparator
        HCP_signals
    end

    methods %% GET, SET
        function g = get.num_nets(~)
            g = length(mlraut.NetworkData.NETWORKS_YEO_NAMES);
        end
        function g = get.num_sub(this)
            g = numel(this.subjects);
        end
        function g = get.num_tasks(this)
            g = numel(this.tasks);
        end

        function g = get.comparator(this)
            g = this.comparator_;
        end
        function g = get.HCP_signals(this)
            g = this.HCP_signals_;
        end
    end
    
    methods
        function psis = average_network_signals(this)
            arguments
                this mlraut.AnalyticSignalHCP
            end

            this.HCP_signals_.cbm.psi = this.average_network_signal(this.bold_signal_, network_type="cerebellar");
            this.HCP_signals_.cbm.phi = this.average_network_signal(this.physio_signal_, network_type="cerebellar");
            this.HCP_signals_.ctx.psi = this.average_network_signal(this.bold_signal_, network_type="cortical");
            this.HCP_signals_.ctx.phi = this.average_network_signal(this.physio_signal_, network_type="cortical");
            this.HCP_signals_.str.psi = this.average_network_signal(this.bold_signal_, network_type="striatal");
            this.HCP_signals_.str.phi = this.average_network_signal(this.physio_signal_, network_type="striatal");
            this.HCP_signals_.thal.psi = this.average_network_signal(this.bold_signal_, network_type="thalamic");
            this.HCP_signals_.thal.phi = this.average_network_signal(this.physio_signal_, network_type="thalamic");
            psis = this.HCP_signals;
        end

        function this = call(this)

            % e.g., exclude subjects
            % this.subjects = this.subjects(~contains(this.subjects, '_7T'));  % 7T studies still listed under tasks
            % this.subjects = this.subjects(~contains(this.subjects, 'sub-'));

            for s = 1:this.num_sub
                try
                    this.current_subject = this.subjects{s};
                    this.call_subject();
                catch ME
                    handwarning(ME)
                end
            end
        end

        function this = call_subject(this)

            for t = 1:this.num_tasks     
                try
                    this.current_task = this.tasks{t};
                    this.call_task();
                catch ME
                    handwarning(ME)
                end
            end
        end

        function this = call_task(this)

            %% Hilbert transform is applied after most other operations
            
            this.malloc();  % resets caches for each task
            this.update_out_dir();

            % BOLD
            try
                bold_gsr_ = ...
                    this.build_global_signal_regressed(this.task_dtseries());
                bold_ = ...
                    this.build_rescaled( ...
                    this.build_band_passed( ...
                    this.build_centered(bold_gsr_)));
                if ~isemptytext(getenv("VERBOSITY")); fprintf("size(bold_):\n"); disp(size(bold_)); end
            catch ME
                disp([this.current_subject ' ' this.current_task ' BOLD missing or defective:']);
                handexcept(ME)
            end

            % physio
            try
                physio_ = this.task_physio();
                if ~isemptytext(getenv("VERBOSITY")); fprintf("size(physio_):\n"); disp(size(physio_)); end
                this.physio_supplementary_ = this.task_physio_supplementary();
                if ~isemptytext(getenv("VERBOSITY"))
                    fprintf("size(physio_supplementary):\n");
                    disp(size(this.physio_supplementary_));
                end
            catch ME
                disp([this.current_subject ' ' this.current_task ' physio missing or defective:']);
                handexcept(ME)
            end

            % Store BOLD signals
            this.bold_signal_ = hilbert(bold_);

            % Store physio signals
            this.physio_signal_ = hilbert(physio_);

            % Store averages for networks
            this.average_network_signals();

            % Store connectivity for comparisons
            this.comparator_ = this.connectivity(bold_, physio_);

            % do plots
            this.meta_plot();

            % do save
            this.meta_save();
        end

        function concat_frames(this, that)
            arguments
                this mlraut.AnalyticSignalHCP
                that mlraut.AnalyticSignalHCP
            end

            concat_frames@mlraut.AnalyticSignal(this, that);
            for fld = asrow(fieldnames(this.HCP_signals_))  % cbm, ctx, str, thal, gbm
                fld_ = fld{1};
                this.HCP_signals_.(fld_).psi = [this.HCP_signals_.(fld_).psi; that.HCP_signals_.(fld_).psi];
                this.HCP_signals_.(fld_).phi = [this.HCP_signals_.(fld_).phi; that.HCP_signals_.(fld_).phi];
            end

            % update comparator
            this.comparator_ = this.connectivity(this.bold_signal_, mean(this.physio_signal_, 2));
        end

        function mat = connectivity(~, bold, seed)
            bold = real(bold)';  % N.B.:  Nx x Nt
            seed = real(seed)';
            seed = mean(seed, 1);  %#ok<UDIM> % N.B.:  1 x Nt
            Nx = size(bold, 1);
            mat = nan(Nx, 1);  % Nx x 1
            for pos = 1:Nx
                R = corrcoef(bold(pos, :), seed);
                mat(pos) = R(1, 2);
            end
        end

        function this = malloc(this)
            %% reset for new tasks or new subjects

            this = malloc@mlraut.AnalyticSignal(this);

            this.comparator_ = [];

            this.HCP_signals_.cbm.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.cbm.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.phi = complex(nan(this.num_frames,this.num_nets));
        end 

        function meta_plot(this)
            if this.do_plot_global_physio
                error("mlraut:NotImplementedError", stackstr())
            end
            if this.do_plot_wavelets
                this.plot_regions(@this.plot_cmor, measure=@this.X);
                this.plot_regions(@this.plot_cmor, measure=@this.Y);
                this.plot_regions(@this.plot_cmor, measure=@this.Z);
                this.plot_regions(@this.plot_cmor, measure=@this.T);
                this.plot_regions(@this.plot_wcoherence, measure=@nan);
                this.plot_regions(@this.plot_cwt, measure=@nan);
            end
            if this.do_plot_networks
                this.plot_regions(@this.plot_networks, measure=@this.X);
                this.plot_regions(@this.plot_networks, measure=@this.Y);
                this.plot_regions(@this.plot_networks, measure=@this.Z);
                this.plot_regions(@this.plot_networks, measure=@this.T);
                this.plot_regions(@this.plot_networks_dots, measure=@this.angle);
                this.plot_regions(@this.plot_networks_dots, measure=@this.unwrap);
            end
            if this.do_plot_radar
                error("mlraut:NotImplementedError", stackstr())
            end
            if this.do_plot_emd
                error("mlraut:NotImplementedError", stackstr())
            end
        end

        function meta_save(this)
            if this.do_save_ciftis

                % connectivity(this.bold_signal_, this.physio_signal_), with matching normalizations
                if ~isempty(this.comparator_)
                    this.write_cifti( ...
                        this.comparator_, ...
                        sprintf('connectivity_sub-%s_ses-%s_%s', this.current_subject, this.current_task, this.tags));
                end

                % ciftis for wb_view, with|without dynamic
                this.write_ciftis(dyn=this.do_save_dynamic);                

                % ciftis with alternative averaging
                if this.do_save_ciftis_alt
                    this.write_ciftis(amethod=@max,atag="_maxt");
                    this.write_ciftis(amethod=@min,atag="_mint");
                end
             
                % regularization by selective sampling
                if this.do_save_regularized
                    unwrap_ = this.unwrap(this.bold_signal_, this.physio_signal_);
                    parts = unwrap_ >= 0;  % leading arousal 
                    this.write_ciftis(tags=this.tags("reg-nonneg"), parts=parts);
                    parts = unwrap_ < 0;  % lagging arousal 
                    this.write_ciftis(tags=this.tags("reg-neg"), parts=parts);
                end
            end
            if this.do_save_ciftis_of_diffs                        
                error("mlraut:NotImplementedError", stackstr())
            end
            if this.do_save
                % Store reduced analytic signals for current_subject, current_task
                % grid of data from s, t may be assessed with stats
                save(this);
            end
        end

        function write_ciftis(this, opts)
            %% Args:
            %      this mlraut.AnalyticSignalHCP
            %      opts.tags {mustBeTextScalar} = this.tags()
            %      opts.amethod function_handle = @mean
            %      opts.atag {mustBeTextScalar} = "_meant"
            %      opts.parts logical = [];
            %      opts.dyn logical = false;            
            %  Returns:
            %      cii struct : for CIFTI
            %      cii1 struct : for CIFTI

            arguments
                this mlraut.AnalyticSignalHCP
                opts.tags {mustBeTextScalar} = this.tags()
                opts.amethod function_handle = @this.cifti_.bin_by_physio_angle
                opts.atag {mustBeTextScalar} = "_binangle"
                opts.parts logical = [];
                opts.dyn logical = false;
            end

            this.cifti_.write_ciftis( ...
                this.T(this.bold_signal_, this.physio_signal_), ...
                sprintf('T_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                averaging_method=opts.amethod, ...
                averaging_tag=opts.atag, ...
                partitions=opts.parts, ...
                do_save_dynamic=opts.dyn);
            this.cifti_.write_ciftis( ...
                this.Z(this.bold_signal_, this.physio_signal_), ...
                sprintf('Z_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                averaging_method=opts.amethod, ...
                averaging_tag=opts.atag, ...
                partitions=opts.parts, ...
                do_save_dynamic=opts.dyn);
            this.cifti_.write_ciftis( ...
                this.X(this.bold_signal_, this.physio_signal_), ...
                sprintf('X_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                averaging_method=opts.amethod, ...
                averaging_tag=opts.atag, ...
                partitions=opts.parts, ...
                do_save_dynamic=opts.dyn);
            try
                this.cifti_.write_ciftis( ...
                    this.Y(this.bold_signal_, this.physio_signal_), ...
                    sprintf('Y_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                    averaging_method=opts.amethod, ...
                    averaging_tag=opts.atag, ...
                    partitions=opts.parts, ...
                    do_save_dynamic=opts.dyn);
            catch ME
                fprintf("%s:  %s\n", stackstr(), ME.message);
                this.cifti_.write_ciftis( ...
                    abs(this.Y(this.bold_signal_, this.physio_signal_)), ...
                    sprintf('abs_Y_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                    averaging_method=opts.amethod, ...
                    averaging_tag=opts.atag, ...
                    partitions=opts.parts, ...
                    do_save_dynamic=opts.dyn);
            end
                averaging_tag=opts.atag, ...
            this.cifti_.write_ciftis( ...
                this.angle(this.bold_signal_, this.physio_signal_), ...
                sprintf('a_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                averaging_method=opts.amethod, ...
                averaging_tag=opts.atag, ...
                partitions=opts.parts, ...
                do_save_dynamic=opts.dyn);
            this.cifti_.write_ciftis( ...
                this.unwrap(this.bold_signal_, this.physio_signal_), ...
                sprintf('u_as_sub-%s_ses-%s_%s', this.current_subject, this.current_task, opts.tags), ...
                averaging_method=opts.amethod, ...
                averaging_tag=opts.atag, ...
                partitions=opts.parts, ...
                do_save_dynamic=opts.dyn);
        end

        function h = plot_coherencyc(this, varargin)
            warning("off", "MATLAB:plot:IgnoreImaginaryXYPart")
            fultz = mlraut.FultzMulti(this);
            fultz.add_phi_psi_from_aso();
            h = figure;
            fultz.plot_coherencyc(varargin{:});
            warning("on", "MATLAB:plot:IgnoreImaginaryXYPart")
        end

        function save(this)
            %% save this fully or a reduced subset

            if this.do_save_subset
                this.save_subset();
                return
            end
            
            try
                save(this.mat_fqfn(), 'this', '-v7.3');
            catch ME
                handwarning(ME)
            end
        end

        function save_subset(this)
            %% reduce size of saved

            this_subset.num_nets = this.num_nets;
            this_subset.num_sub = this.num_sub;
            this_subset.num_tasks = this.num_tasks;
            this_subset.comparator = this.comparator;
            this_subset.HCP_signals = this.HCP_signals;
            this_subset.do_global_signal_regression = this.do_global_signal_regression;
            this_subset.do_plot_emd = this.do_plot_emd;
            this_subset.do_plot_global_physio = this.do_plot_global_physio;
            this_subset.do_plot_networks = this.do_plot_networks;
            this_subset.do_plot_radar = this.do_plot_radar;
            this_subset.do_plot_wavelets = this.do_plot_wavelets;
            this_subset.do_save = this.do_save;
            this_subset.do_save_bias_to_rsns = this.do_save_bias_to_rsns;
            this_subset.do_save_ciftis = this.do_save_ciftis;
            this_subset.do_save_ciftis_of_diffs = this.do_save_ciftis_of_diffs;
            this_subset.do_save_dynamic = this.do_save_dynamic;
            this_subset.do_save_subset = this.do_save_subset;
            this_subset.filter_order = this.filter_order;
            this_subset.force_band = this.force_band;
            this_subset.force_legacy_butter = this.force_legacy_butter;
            this_subset.frac_ext_physio = this.frac_ext_physio;
            this_subset.norm = this.norm;
            this_subset.source_physio = this.source_physio;
            this_subset.source_physio_supplementary = this.source_physio_supplementary;
            this_subset.v_physio = this.v_physio;
            this_subset.anatomy_list = this.anatomy_list;
            this_subset.digital_filter = this.digital_filter;
            this_subset.global_signal = this.global_signal;
            this_subset.hp_thresh = this.hp_thresh;
            this_subset.lp_thresh = this.hp_thresh;
            this_subset.rescaling = this.rescaling;
            this_subset.rsn_list = this.rsn_list;
            this_subset.tags_user = this.tags_user;
            this_subset.bold_signal = this.bold_signal;
            this_subset.physio_angle = this.physio_angle;
            this_subset.physio_signal = this.physio_signal;
            this_subset.physio_supplementary = this.physio_supplementary;
            this_subset.roi = this.roi;
            this_subset.v_physio_is_inf = this.v_physio_is_inf;
            this_subset.do_7T = this.do_7T;
            this_subset.do_resting = this.do_resting;
            this_subset.do_task = this.do_task;
            this_subset.max_frames = this.max_frames;
            this_subset.current_subject = this.current_subject;
            this_subset.current_task = this.current_task;
            this_subset.subjects = this.subjects;
            this_subset.tasks = this.tasks;
            this_subset.extended_task_dir = this.extended_task_dir;
            this_subset.Fs = this.Fs;
            this_subset.num_frames = this.num_frames;
            this_subset.num_frames_ori = this.num_frames_ori;
            this_subset.num_frames_to_trim = this.num_frames_to_trim;
            this_subset.num_nodes = this.num_nodes;
            this_subset.out_dir = this.out_dir;
            this_subset.root_dir = this.root_dir;
            this_subset.stats_fqfn = this.stats_fqfn;
            this_subset.task_dir = this.task_dir;
            this_subset.task_dtseries_fqfn = this.task_dtseries_fqfn;
            this_subset.task_niigz_fqfn = this.task_niigz_fqfn;
            this_subset.task_ref_niigz_fqfn = this.task_ref_niigz_fqfn;
            this_subset.task_ref_dscalar_fqfn = this.task_ref_dscalar_fqfn;
            this_subset.thickness_dscalar_fqfn = this.thickness_dscalar_fqfn;
            this_subset.t1w_fqfn = this.t1w_fqfn;
            this_subset.tr = this.tr;
            this_subset.waves_dir = this.waves_dir;
            this_subset.wmparc_fqfn = this.wmparc_fqfn;
            this_subset.workbench_dir = this.workbench_dir;

            this_subset.class = class(this);

            try
                save(this.mat_fqfn(), 'this_subset', '-v7.3');
            catch ME
                handwarning(ME)
            end
        end

        function this = AnalyticSignalHCP(varargin)
            this = this@mlraut.AnalyticSignal(varargin{:});
        end
    end

    methods (Static)
        function this = load(fqfn, opts)
            %% Loads fqfn containing this or this_subset, rebuilding mlraut.AnalyticSignalHCP for the latter.

            arguments
                fqfn {mustBeFile}
                opts.tag {mustBeTextScalar} = string(datetime("now", Format="yyyyMMddHHmmss"))
            end

            ld = load(fqfn);
            if isfield(ld, "this") && isa(ld.this, "mlraut.AnalyticSignalHCP")
                this = ld.this;
                return
            end

            if isfield(ld, "this_subset") && isstruct(ld.this_subset)
                this_subset = ld.this_subset;

                if isfield(this_subset, "class")
                    if contains(this_subset.class, "AnalyticSignalGBM")
                        this = mlraut.AnalyticSignalGBM( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    elseif contains(this_subset.class, "AnalyticSignalHCPAging")
                        this = mlraut.AnalyticSignalHCPAging( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    elseif contains(this_subset.class, "AnalyticSignalHCP")
                        this = mlraut.AnalyticSignalHCP( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    else
                        error("mlraut:RuntimeError", stackstr())
                    end
                else
                    if contains(this_subset.out_dir, "AnalyticSignalGBM")
                        this = mlraut.AnalyticSignalGBM( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    elseif contains(this_subset.out_dir, "AnalyticSignalHCPAging")
                        this = mlraut.AnalyticSignalHCPAging( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    elseif contains(this_subset.out_dir, "AnalyticSignalHCP")
                        this = mlraut.AnalyticSignalHCP( ...
                            max_frames=this_subset.max_frames, subjects=this_subset.subjects, tasks=this_subset.tasks);
                    else
                        error("mlraut:RuntimeError", stackstr())
                    end
                end
                 
                % this_subset.num_nets;  % dependent prop
                % this_subset.num_sub;  % dependent prop
                % this.num_tasks_ = this_subset.num_tasks;  % dependent prop
                this.comparator_ = this_subset.comparator;
                this.HCP_signals_ = this_subset.HCP_signals;
                this.do_global_signal_regression = this_subset.do_global_signal_regression;
                this.do_plot_emd = this_subset.do_plot_emd;
                this.do_plot_global_physio = this_subset.do_plot_global_physio;
                this.do_plot_networks = this_subset.do_plot_networks;
                this.do_plot_radar = this_subset.do_plot_radar;
                this.do_plot_wavelets = this_subset.do_plot_wavelets;
                this.do_save = this_subset.do_save;
                this.do_save_ciftis = this_subset.do_save_ciftis;
                this.do_save_ciftis_alt = this_subset.do_save_ciftis_alt; 
                % this.do_save_ciftis_alt = false;  % this_subset.do_save_ciftis_alt;  % bug from 4/17/2025: missing in save_subset()
                this.do_save_ciftis_of_diffs = this_subset.do_save_ciftis_of_diffs;
                this.do_save_dynamic = this_subset.do_save_dynamic;
                this.do_save_regularized = this_subset.do_save_regularized;
                this.do_save_subset = this_subset.do_save_subset;
                this.filter_order = this_subset.filter_order;
                this.force_band = this_subset.force_band;
                this.force_legacy_butter = this_subset.force_legacy_butter;
                this.frac_ext_physio = this_subset.frac_ext_physio;
                this.norm = this_subset.norm;
                this.source_physio = this_subset.source_physio;
                this.source_physio_supplementary = this_subset.source_physio_supplementary;
                this.v_physio = this_subset.v_physio;
                this.anatomy_list_ = this_subset.anatomy_list;
                this.digital_filter_ = this_subset.digital_filter;
                this.global_signal_ = this_subset.global_signal;
                this.hp_thresh_ = this_subset.hp_thresh;
                this.lp_thresh_ = this_subset.lp_thresh;
                % this.hp_thresh_ = [];  % this_subset.hp_thresh;  % bug from 4/17/2025: hp_thresh <- lp_thresh 
                % this.lp_thresh_ = 0.1;  % this_subset.lp_thresh;
                this.rescaling_ = this_subset.rescaling;
                % this.rsn_list_ = this_subset.rsn_list;  % dependent prop
                this.tags_user_ = this_subset.tags_user + "-" + opts.tag;
                this.bold_signal_ = this_subset.bold_signal;
                this.physio_angle_ = this_subset.physio_angle;
                this.physio_signal_ = this_subset.physio_signal;
                this.physio_supplementary_ = this_subset.physio_supplementary;
                this.roi_ = this_subset.roi;
                % this.v_physio_is_inf_ = this_subset.v_physio_is_inf;  % dependent prop
                this.do_7T = this_subset.do_7T;
                this.do_resting = this_subset.do_resting;
                this.do_task = this_subset.do_task;
                % this.max_frames = this_subset.max_frames;  % passed to ctor
                this.current_subject_ = this_subset.current_subject;
                this.current_task_ = this_subset.current_task;
                % this.subjects_ = this_subset.subjects;  % passed to ctor
                % this.tasks_ = this_subset.tasks;  % passed to ctor
                % this.extended_task_dir_ = this_subset.extended_task_dir;  % dependent prop
                % this.Fs = this_subset.Fs;  % dependent prop
                % this.num_frames_ = this_subset.num_frames;  % dependent prop
                % this.num_frames_ori_ = this_subset.num_frames_ori;  % dependent prop
                % this.num_frames_to_trim_ = this_subset.num_frames_to_trim;  % dependent prop
                % this.num_nodes_ = this_subset.num_nodes;  % dependent prop
                % this.out_dir_ = this_subset.out_dir;  % dependent prop
                % this.root_dir_ = this_subset.root_dir;  % dependent prop
                % this.stats_fqfn_ = this_subset.stats_fqfn;  % dependent prop
                % this.task_dir_ = this_subset.task_dir;  % dependent prop
                % this.task_dtseries_fqfn_ = this_subset.task_dtseries_fqfn;  % dependent prop
                % this.task_niigz_fqfn_ = this_subset.task_niigz_fqfn;  % dependent prop
                % this.task_ref_niigz_fqfn_ = this_subset.task_ref_niigz_fqfn;  % dependent prop
                % this.task_ref_dscalar_fqfn_ = this_subset.task_ref_dscalar_fqfn;  % dependent prop
                % this.thickness_dscalar_fqfn_ = this_subset.thickness_dscalar_fqfn;  % dependent prop
                % this.t1w_fqfn_ = this_subset.t1w_fqfn;  % dependent prop
                % this.tr_ = this_subset.tr;  % dependent prop
                % this.waves_dir_ = this_subset.waves_dir;  % dependent prop
                % this.wmparc_fqfn_ = this_subset.wmparc_fqfn;  % dependent prop
                % this.workbench_dir_ = this_subset.workbench_dir;  % dependent prop

                % HCP.malloc()
                this.bold_data_ = mlraut.BOLDData(this);
                this.cifti_ = mlraut.Cifti(this);
                this.cohort_data_ = mlraut.CohortData.create(this);
                this.cohort_data_.out_dir = this_subset.out_dir;
                this.twistors_ = mlraut.Twistors(this);

                % AnalyticSignal.malloc()
                plot_range_ = 1:round(200/this.tr);
                this.plotting_ = mlraut.Plotting.create(this, plot_range=plot_range_);
                return
            end

            error("mlraut:ValueError", stackstr())
        end
    end

    %% PROTECTED

    properties (Access = protected)
        comparator_
        HCP_signals_
    end

    methods (Access = protected)
        function this = update_out_dir(this)
            out_dir_ = this.out_dir;
            if ~contains(out_dir_, this.current_subject)  % add subject folder to out_dir as needed
                out_dir_ = fullfile(out_dir_, this.current_subject);
                ensuredir(out_dir_);
                this.out_dir = out_dir_;
            end
        end
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
