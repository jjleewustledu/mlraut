classdef AnalyticSignalHCP < handle & mlraut.AnalyticSignal
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties (Dependent)
        num_nets
        num_sub
        num_tasks

        comparator
        HCP_signals
    end

    methods %% GET, SET
        function g = get.num_nets(~)
            g = length(mlraut.NetworkData.NETWORKS_YEO_NAMES);
        end
        function g = get.num_sub(this)
            g = numel(this.subjects);
        end
        function g = get.num_tasks(this)
            g = numel(this.tasks);
        end

        function g = get.comparator(this)
            g = this.comparator_;
        end
        function g = get.HCP_signals(this)
            g = this.HCP_signals_;
        end
    end
    
    methods
        function psis = average_network_signals(this, psi, phi)
            arguments
                this mlraut.AnalyticSignalHCP
                psi {mustBeNumeric}
                phi {mustBeNumeric}
            end

            this.HCP_signals_.cbm.psi = this.average_network_signal(psi, network_type="cerebellar");
            this.HCP_signals_.cbm.phi = this.average_network_signal(phi, network_type="cerebellar");
            this.HCP_signals_.ctx.psi = this.average_network_signal(psi, network_type="cortical");
            this.HCP_signals_.ctx.phi = this.average_network_signal(phi, network_type="cortical");
            this.HCP_signals_.str.psi = this.average_network_signal(psi, network_type="striatal");
            this.HCP_signals_.str.phi = this.average_network_signal(phi, network_type="striatal");
            this.HCP_signals_.thal.psi = this.average_network_signal(psi, network_type="thalamic");
            this.HCP_signals_.thal.phi = this.average_network_signal(phi, network_type="thalamic");
            psis = this.HCP_signals;
        end

        function this = call(this, opts)
            %% CALL all subjects

            arguments
                this mlraut.AnalyticSignalHCP
                opts.do_qc logical = false
            end

            % exclude subjects
            this.subjects = this.subjects(~contains(this.subjects, '_7T'));  % 7T studies still listed under tasks
            %this.subjects = this.subjects(~contains(this.subjects, 'sub-'));

            out_dir_ = this.out_dir;
            for s = 1:this.num_sub
                try
                    this.current_subject = this.subjects{s};
                    if ~contains(out_dir_, this.current_subject)
                        proposed_dir = fullfile(out_dir_, this.current_subject);
                        this.out_dir = proposed_dir;
                        ensuredir(proposed_dir);
                    end
                    this.call_subject(s);
                catch ME
                    handexcept(ME)
                end
            end
        end

        function this = call_subject(this, s)

            %% Hilbert transform is applied after most other operations

            arguments
                this %  mlraut.AnalyticSignalHCP; avoid down-casting
                s double
            end

            for t = 1:this.num_tasks     
                try
                    this.malloc();
                    this.current_task = this.tasks{t};

                    % BOLD
                    try
                        bold_gsr_ = ...
                            this.build_global_signal_regressed(this.task_dtseries());
                        bold_ = ...
                            this.build_rescaled( ...
                            this.build_band_passed( ...
                            this.build_centered(bold_gsr_)));
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' BOLD missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % physio
                    try
                        [physio_,physio__] = this.task_physio(reference=bold_);
                    catch ME
                        disp([this.current_subject ' ' this.current_task ' physio missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % Store BOLD signals
                    this.bold_signal_ = hilbert(bold_);

                    % Store physio signals
                    this.physio_signal_ = hilbert(physio_);

                    % Averages for networks
                    this.average_network_signals(this.bold_signal_, this.physio_signal_);

                    % connectivity for comparisons
                    this.comparator_ = this.connectivity(bold_, physio__);

                    % Store reduced analytic signal, real(), imag(), abs(), angle()
                    if this.do_save
                        % Store reduced analytic signals for all s, t
                        % grid of data from s, t may be assessed with stats
                        save(this, s, t);
                    end
                    if this.do_save_ciftis

                        % connectivity(this.bold_signal_, this.physio_signal_), with matching normalizations
                        this.write_cifti( ...
                            this.comparator_, ...
                            sprintf('connectivity_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags));

                        % (T,X,Y,Z) in omega
                        psi = this.bold_signal_;
                        phi = this.physio_signal_;
                        % parts = this.physio_angle >= 0;  % unbiased, but fails to separate features
                        parts = this.X(this.HCP_signals.ctx.psi(:,9), this.HCP_signals.ctx.phi(:,9)) >= 0;  
                        % cortical X(psi, phi) >= 0, region 9 ~ task-, biased but informative
                        
                        this.write_ciftis( ...
                            this.T(psi, phi), ...
                            sprintf('T_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            this.X(psi, phi), ...
                            sprintf('X_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            this.Y(psi, phi), ...
                            sprintf('Y_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            this.Z(psi, phi), ...
                            sprintf('Z_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);
                        this.write_ciftis( ...
                            this.angle(psi, phi), ...
                            sprintf('angle_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);  
                        this.write_ciftis( ...
                            this.unwrap(psi, phi), ...
                            sprintf('unwrap_as_sub-%s_ses-%s_%s', this.subjects{s}, this.tasks{t}, this.tags), ...
                            partitions=parts, ...
                            do_save_dynamic=this.do_save_dynamic);   

                    end
                    if this.do_save_ciftis_of_diffs                        
                        error("mlraut:NotImplementedError", stackstr())
                    end
            arguments
                this %  mlraut.AnalyticSignalHCP
                physio_keys string {mustBeText}
                physio_vs double = [this.v_physio_iFV, this.v_physio]
                weights double = [0.5, 0.5]
            end
            assert(length(physio_keys) == 2)
            assert(length(physio_vs) == 2)
            assert(length(weights) == 2)

                    % do plot
                    if this.do_plot_global_physio
                        error("mlraut:NotImplementedError", stackstr())
                    end
                    if this.do_plot_networks
                        this.plot_regions(@this.plot_networks, measure=@this.X);
                        this.plot_regions(@this.plot_networks, measure=@this.Y);
                        this.plot_regions(@this.plot_networks, measure=@this.Z);
                        this.plot_regions(@this.plot_networks, measure=@this.T);
                        this.plot_regions(@this.plot_networks, measure=@this.angle);
                        this.plot_regions(@this.plot_networks, measure=@this.unwrap);
                    end
                    if this.do_plot_radar
                        error("mlraut:NotImplementedError", stackstr())
                    end
                    if this.do_plot_emd
                        error("mlraut:NotImplementedError", stackstr())
                    end
                catch ME
                    handwarning(ME)
                end
            end
        end  

        function mat = connectivity(~, bold, seed)
            bold = real(bold)';  % Nx x Nt
            seed = real(seed)';  % 1 x Nt
            Nx = size(bold, 1);
            mat = nan(Nx, 1);  % Nx x 1
            for pos = 1:Nx
                R = corrcoef(bold(pos, :), seed);
                mat(pos) = R(1, 2);
            end
        end

        function obj = identity(~, obj)
        end

        function this = malloc(this)

            % accumulate for statistics on serialized AnalyticSignalHCP
            this.bold_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest
            this.physio_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest       

            this.HCP_signals_.cbm.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.cbm.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.ctx.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.str.phi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.psi = complex(nan(this.num_frames,this.num_nets));
            this.HCP_signals_.thal.phi = complex(nan(this.num_frames,this.num_nets));
        end

        function save(this, s, t)

            if this.do_save_subset

                %% reduce size of saved

                this_subset.digital_filter = this.digital_filter;
                this_subset.do_7T = this.do_7T;
                this_subset.do_resting = this.do_resting;
                this_subset.do_task = this.do_task;
                this_subset.do_save = this.do_save;
                this_subset.do_save_ciftis = this.do_save_ciftis;
                this_subset.do_save_ciftis_of_diffs = this.do_save_ciftis_of_diffs;
                this_subset.do_save_dynamic = this.do_save_dynamic;
                this_subset.force_band = this.force_band;
                this_subset.final_normalization = this.final_normalization;
                this_subset.roi = this.roi;
                this_subset.source_physio = this.source_physio;
                this_subset.global_signal = this.global_signal;
                this_subset.global_signal_regression = this.global_signal_regression;
                this_subset.hp_thresh = this.hp_thresh;
                this_subset.lp_thresh = this.lp_thresh;
                this_subset.num_nets = this.num_nets;
                this_subset.num_sub = this.num_sub;
                this_subset.num_tasks = this.num_tasks;
                this_subset.scale_to_hcp = this.scale_to_hcp;
                this_subset.tags = this.tags;
                this_subset.bold_signal = this.bold_signal;
                this_subset.HCP_signals = this.HCP_signals;
                this_subset.physio_signal = this.physio_signal;
                this_subset.comparator = this.comparator;
                this_subset.max_frames = this.max_frames;
                this_subset.current_subject = this.current_subject;
                this_subset.current_task = this.current_task;
                this_subset.subjects = this.subjects;
                this_subset.tasks = this.tasks;
                % this_subset.bold_data = this.bold_data;
                % this_subset.cohort_data = this.cohort_data;
                % this_subset.cifti_last = this.cifti_last;
                this_subset.Fs = this.Fs;
                this_subset.num_frames = this.num_frames;
                this_subset.num_frames_ori = this.num_frames_ori;
                this_subset.num_frames_to_trim = this.num_frames_to_trim;
                this_subset.num_nodes = this.num_nodes;
                this_subset.out_dir = this.out_dir;
                this_subset.root_dir = this.root_dir;
                this_subset.task_dir = this.task_dir;
                this_subset.task_dtseries_fqfn = this.task_dtseries_fqfn;
                this_subset.task_niigz_fqfn = this.task_niigz_fqfn;
                this_subset.task_signal_reference_fqfn = this.task_signal_reference_fqfn;
                this_subset.t1w_fqfn = this.t1w_fqfn;
                this_subset.tr = this.tr;
                this_subset.waves_dir = this.waves_dir;
                this_subset.wmparc_fqfn = this.wmparc_fqfn;
                this_subset.workbench_dir = this.workbench_dir;
                try
                    save(fullfile(this.out_dir, ...
                        sprintf("sub-%s_ses-%s_%s_subset.mat", this.subjects{s}, strrep(this.tasks{t}, "_", "-"), this.tags)), ...
                        'this_subset');
                catch ME
                    handwarning(ME)
                end
                return
            end

            try
                save(fullfile(this.out_dir, ...
                    sprintf("sub-%s_ses-%s_%s.mat", this.subjects{s}, strrep(this.tasks{t}, "_", "-"), this.tags)), ...
                    'this');
            catch ME
                handwarning(ME)
            end
        end

        function this = AnalyticSignalHCP(varargin)
            this = this@mlraut.AnalyticSignal(varargin{:});
        end
    end

    %% PROTECTED

    properties (Access = protected)
        comparator_
        HCP_signals_
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
