classdef AnalyticSignal < handle & mlraut.HCP
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    
    properties
        do_plot_emd
        do_plot_networks
        do_plot_radar
        do_save
        hp_thresh % lower bound, Ryan ~ 0.01, units of 1/tr
        lp_thresh % higher bound, Ryan ~ 0.05, units of 1/tr
        normalization
        source_physio

        analytic_signals
        global_signals
        HCP_signals
        physio_signals
    end

    properties (Dependent)
        min_physN % min physio samples to accept
        num_sub
        num_tasks
        physFs % Physio sampling rate, Hz
        subjects
        tags % for filenames
        tasks    
    end

    methods

        %% GET
        
        function g = get.min_physN(~)
            g = 860;
        end
        function g = get.num_sub(this)
            g = numel(this.subjects);
        end
        function g = get.num_tasks(this)
            g = numel(this.tasks);
        end
        function g = get.physFs(~)
            g = 400;
        end
        function g = get.subjects(this)
            g = this.subjects_;
        end
        function g = get.tags(this)
            if isempty(this.normalization) && strcmp(this.source_physio, 'iFV')
                g = '';
                return
            end
            g = '_proc';
            if ~isempty(this.normalization)
                g = sprintf('%s-%s', g, this.normalization);
            end
            if ~strcmp(this.source_physio, 'iFV')
                g = strcat(g, '-', this.source_physio);
            end
        end
        function g = get.tasks(this)
            g = this.tasks_;
        end

        %%

        function a = angle(~, as)
            a = unwrap(angle(as)); % [-pi pi] -> [-inf inf]
            a = mod(a, 2*pi); % [-inf inf] -> [0 2*pi]
        end
        function this = average_network_signals(this, psi, s, t)
            assert(isscalar(s));
            assert(isscalar(t));

            Nrsn = sum(~contains(this.RSN_NAMES, 'task'));
            for n = 1:Nrsn % Yeo's RSNs
                for h = {'cbm', 'ctx', 'str', 'thal'}
                    msk = this.networks_HCP == n & this.masks_HCP.(h{1});
                    target = this.HCP_signals.(h{1});
                    target(:,n,s,t) = median(psi(:,msk), 2, 'omitnan');
                    this.HCP_signals.(h{1}) = target;
                end
            end

            task_pos = 1 <= this.networks_HCP & this.networks_HCP <= 5;
            task_neg = 6 <= this.networks_HCP & this.networks_HCP <= 7;

            % task+
            for h = {'cbm', 'ctx', 'str', 'thal'}
                idx = contains(this.RSN_NAMES, 'task+');
                msk = task_pos & this.masks_HCP.(h{1});
                target = this.HCP_signals.(h{1});
                target(:,idx,s,t) = median(psi(:,msk), 2, 'omitnan');
                this.HCP_signals.(h{1}) = target;
            end

            % task-
            for h = {'cbm', 'ctx', 'str', 'thal'}
                idx = contains(this.RSN_NAMES, 'task-');
                msk = task_neg & this.masks_HCP.(h{1});
                target = this.HCP_signals.(h{1});
                target(:,idx,s,t) = median(psi(:,msk), 2, 'omitnan');
                this.HCP_signals.(h{1}) = target;
            end
        end
        function dat1 = band_pass(this, dat)
            %% Implements butter:  web(fullfile(docroot, 'signal/ref/butter.html?browser=F1help#bucsfmj')) .
            %  See also web(fullfile(docroot, 'signal/ug/practical-introduction-to-digital-filtering.html')) .
            %  Returns:
            %      dat1 same num. type as dat

            if isempty(this.lp_thresh) && isempty(this.hp_thresh)
                return
            end
            [z,p,k] = butter(2, [this.hp_thresh, this.lp_thresh]/(this.Fs/2));
            [sos,g] = zp2sos(z, p, k);
            dat1 = filtfilt(sos, g, double(dat));
            if isa(dat, 'single')
                dat1 = single(dat1);
            end
            if isa(dat, 'double')
                dat1 = double(dat1);
            end
        end
        function this = call(this)
            subjects_dir = this.out_dir;

            for s = 1:this.num_sub                        
                sub = this.subjects{s};    
                sub_dir = fullfile(subjects_dir, sub);
                ensuredir(sub_dir);
                this.out_dir = sub_dir;

                for t = 1:this.num_tasks
                    task = this.tasks{t}; 

                    tic           

                    % BOLD
                    try
                        bold = this.task_dtseries(sub, task); 
                        assert(~isempty(bold))
                        if size(bold,1) ~= this.num_frames, continue, end
                    catch ME
                        disp([sub ' ' task ' BOLD missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % Global signal
                    gs = this.global_signal(bold);
                     
                    % Physio
                    try
                        physio = this.task_physio(sub, task, bold);
                        assert(~isempty(physio))
                    catch ME
                        disp([sub ' ' task ' physio missing or defective:']);
                        handwarning(ME)
                        continue
                    end

                    % Analytic signal
                    bold_ = this.center_and_rescale(this.band_pass(bold - gs));
                    physio_ = this.center_and_rescale(this.band_pass(physio)); % removes gs as needed
                    as = conj(hilbert(physio_)).*hilbert(bold_); % <psi_p|BOLD_operator|psi_p> ~ <psi_p|psi_b>, not unitary
                    as = this.normalize(as);
            
                    % Store reduced analytic signal, real(), imag(), abs(), angle()
                    save(fullfile(this.out_dir, sprintf('%s_as%s_%i_%i', stackstr(2), this.tags, s, t)), 'as');
                    this.write_cifti(real(as), sprintf('real_as%s_%i_%i', this.tags, s, t));
                    this.write_cifti(imag(as), sprintf('imag_as%s_%i_%i', this.tags, s, t));
                    this.write_cifti(abs(as), sprintf('abs_as%s_%i_%i', this.tags, s, t));
                    this.write_cifti(angle(as), sprintf('angle_as%s_%i_%i', this.tags, s, t));

                    % Store reduced analytic signals for all s, t
                    this.analytic_signals(:,:,s,t) = as;
                    this.global_signals(:,s,t) = hilbert(this.center_and_rescale(this.band_pass(gs)));
                    this.physio_signals(:,s,t) = hilbert(this.center_and_rescale(this.band_pass(physio)));

                    this.average_network_signals(as, s, t)
                    if this.do_plot_emd
                        this.plot_networks(measure=@this.unwrap, isub=s, itask=t)
                        this.saveFigures('emd_unwrap', s, t);
                        this.plot_networks(measure=@abs, isub=s, itask=t)
                        this.saveFigures('emd_abs', s, t);
                        this.plot_networks(measure=@real, isub=s, itask=t)
                        this.saveFigures('emd_real', s, t);
                        this.plot_networks(measure=@imag, isub=s, itask=t)
                        this.saveFigures('emd_imag', s, t);
                    end
                    if this.do_plot_networks
                        this.plot_networks(measure=@this.unwrap, isub=s, itask=t)
                        this.saveFigures('networks_unwrap', s, t);
                        this.plot_networks(measure=@angle, isub=s, itask=t)
                        this.saveFigures('networks_angle', s, t);
                        this.plot_networks(measure=@abs, isub=s, itask=t)
                        this.saveFigures('networks_abs', s, t);
                        this.plot_networks(measure=@real, isub=s, itask=t)
                        this.saveFigures('networks_real', s, t);
                        this.plot_networks(measure=@imag, isub=s, itask=t)
                        this.saveFigures('networks_imag', s, t);
                    end
                    if this.do_plot_radar
                        this.plot_radar(isub=s, itask=t)
                        this.saveFigures('radar', s, t);
                    end

                    toc
                end                
            end
            this.out_dir = subjects_dir;
            if this.do_save
                save(this)
            end
        end
        function psi = center(~,psi)
            %% Centers to ensure unitary evolution of |psi(t,x)>.

            assert(~isempty(psi))
            psi = psi - median(psi, 'all', 'omitnan');
        end
        function psi = center_and_rescale(this, psi)
            psi = this.center(psi);
            psi = this.rescale(psi);
        end
        function gs = global_signal(this, sig)
            %% global_signal := median(sig(t,x), 2)

            assert(~isempty(sig))
            assert(size(sig, 1) == this.num_frames)
            assert(size(sig, 2) == this.num_nodes)

            gs = median(sig, 2);
        end
        function as = normalize(this, as)
            switch this.normalization
                case 'normgs'
                    as = as ./ abs(this.global_signal(as));
                otherwise
                    return
            end
        end
        function data = physio_log(this, sub, task)
            fqfn = fullfile( ...
                this.data_dir(sub, task), strcat(task, '_Physio_log.txt'));
            data = importdata(fqfn);
            assert(length(data)/this.physFs >= this.min_physN, stackstr(2))
        end
        function [h1,h3] = plot_networks(this, opts)
            %  Args:
            %      this mlraut.AnalyticSignal           
            %      opts.measure function_handle = @angle
            %      opts.region {mustBeTextScalar} = 'ctx'
            %      opts.isub {mustBeInteger} = 1
            %      opts.itask {mustBeInteger} = 1

            arguments
                this mlraut.AnalyticSignal           
                opts.measure function_handle = @angle
                opts.region {mustBeTextScalar} = 'ctx'
                opts.isub {mustBeInteger} = 1
                opts.itask {mustBeInteger} = 1
            end
            assert(contains(opts.region, {'cbm', 'ctx', 'str', 'thal'}))
            s_ = opts.isub;
            t_ = opts.itask;
            signals = this.HCP_signals.(lower(opts.region));
            secs_ = this.tr * (0:this.num_frames-1);

            % plot Yeo's 7 RSNs
            h1 = figure;
            h1.Position = [0 0 2880 2880*0.618];
            hold on
            for k = 1:5
                plot(secs_, opts.measure(signals(:, k, s_, t_)));
            end
            plot(secs_, opts.measure(signals(:, 6, s_, t_)), '--', LineWidth=2); % frontoparietal
            plot(secs_, opts.measure(signals(:, 7, s_, t_)), '--', LineWidth=2); % default mode
            legend(this.RSN_NAMES(1:7), FontSize=18)
            xlabel('time/s', FontSize=24)
            ylabel(sprintf('%s(%s_signals)', char(opts.measure), opts.region), FontSize=24, Interpreter="none")
            title(sprintf('Yeo RSNs, sub-%s, %s ', this.subjects{s_}, this.tasks{t_}), FontSize=24, Interpreter="none")
            hold off

            % plot task+, task- RSNs
            h3 = figure;
            h3.Position = [0 0 2880 2880*0.618];
            hold on
            plot(secs_, opts.measure(signals(:, 8, s_, t_)));
            plot(secs_, opts.measure(signals(:, 9, s_, t_)), '--', LineWidth=2);
            legend(this.RSN_NAMES(8:9), FontSize=18)
            xlabel('time/s', FontSize=24)
            ylabel(sprintf('%s(%s_signals)', char(opts.measure), opts.region), FontSize=24, Interpreter="none")
            title(sprintf('Task +/-, sub-%s, %s ', this.subjects{s_}, this.tasks{t_}), FontSize=24, Interpreter="none")
            hold off
        end
        function [h,h1] = plot_radar(this, opts)
            %  Args:
            %      this mlraut.AnalyticSignal           
            %      opts.region {mustBeTextScalar} = 'ctx'
            %      opts.isub {mustBeInteger} = 1
            %      opts.itask {mustBeInteger} = 1

            arguments
                this mlraut.AnalyticSignal
                opts.region {mustBeTextScalar} = 'ctx'
                opts.isub {mustBeInteger} = 1
                opts.itask {mustBeInteger} = 1
            end
            assert(contains(opts.region, {'cbm', 'ctx', 'str', 'thal'}))
            s_ = opts.isub;
            t_ = opts.itask;
            signals = this.HCP_signals.(lower(opts.region));

            % plot "radar" of RSNs, global signal, and physio
            h = figure;
            h.Position = [0 0 2880*0.618 2880*0.618];
            hold on
            for k = 1:3
                plot(signals(:, k, s_, t_));
            end
            plot(signals(:, 6, s_, t_), ':', LineWidth=2)
            plot(signals(:, 7, s_, t_), ':', LineWidth=2)
            legend([this.RSN_NAMES(1:3) this.RSN_NAMES(6:7)], FontSize=18)
            xlabel(sprintf('real(%s_signals)', opts.region), FontSize=24, Interpreter="none")
            ylabel(sprintf('imag(%s_signals)', opts.region), FontSize=24, Interpreter="none")
            hold off

            % plot "radar" of task+, task-, global signal, and physio
            h1 = figure;
            h1.Position = [0 0 2880*0.618 2880*0.618];
            hold on
            plot(signals(:, 8, s_, t_), ':', LineWidth=2)
            plot(signals(:, 9, s_, t_), ':', LineWidth=2)
            plot(this.global_signals(:, s_, t_), '-.')
            plot(this.physio_signals(:, s_, t_), '-.')
            legend({'task+', 'task-', 'global', 'physio'}, FontSize=18)
            xlabel(sprintf('real(%s_signals)', opts.region), FontSize=24, Interpreter="none")
            ylabel(sprintf('imag(%s_signals)', opts.region), FontSize=24, Interpreter="none")
            hold off
        end
        function plot_emd(this, opts)
            %  Args:
            %      this mlraut.AnalyticSignal           
            %      opts.measure function_handle = @angle
            %      opts.region {mustBeTextScalar} = 'ctx'
            %      opts.isub {mustBeInteger} = 1
            %      opts.itask {mustBeInteger} = 1

            arguments
                this mlraut.AnalyticSignal    
                opts.freq_limits {mustBeNumeric} = []
                opts.measure function_handle = @real
                opts.region {mustBeTextScalar} = 'ctx'
                opts.isub {mustBeInteger} = 1
                opts.itask {mustBeInteger} = 1
            end
            assert(contains(opts.region, {'cbm', 'ctx', 'str', 'thal'}))
            s_ = opts.isub;
            t_ = opts.itask;
            signals = this.HCP_signals.(lower(opts.region));
            if isempty(opts.freq_limits)
                Flim = [this.hp_thresh this.lp_thresh];
            else
                Flim = opts.freq_limits;
            end

            % emd
            if ~this.do_plot_emd % which automates many plots
                for k = 1:9
                    emd(opts.measure(signals(:,k,s_,t_)), SiftMaxIterations=256)
                    set(gcf, Position=[0 0 2880*0.618 2880*0.618]);
                    title(sprintf('EMD %s, showing 3 IMFs, RSN %s\n', char(opts.measure), this.RSN_NAMES{k}), FontSize=14)
                end
            end

            % hht
            h2 = figure;
            h2.Position = [0 0 2880 2880*0.618];
            tiledlayout(3,3);
            for k = 1:9
                nexttile
                hht(emd(opts.measure(signals(:,k,s_,t_))), this.Fs, FrequencyLimits=Flim); % MaxNumIMF=5
                title(sprintf('Hilbert Spectrum, opts.measure, %s', char(opts.measure), this.RSN_NAMES{k}))
            end

            % fsst
            h3 = figure;
            h3.Position = [0 0 2880 2880*0.618];
            tiledlayout(3,3);
            for k = 1:9
                nexttile
                fsst(opts.measure(signals(:,k,s_,t_)), this.Fs, 'yaxis')
                title(sprintf('Fourier synchrosqueezed transform, %s, %s', char(opts.measure), this.RSN_NAMES{k}))
            end
        end
        function psi = rescale(~, psi)
            %% Rescales to ensure unitary evolution of |psi(t,x)>.

            assert(~isempty(psi))
            if ~isreal(psi)
                d = complex(mad(psi, 1, 'all'), mad(psi, 1, 'all'));
            else
                d = mad(psi, 1, 'all');
            end
            psi = psi./d;
        end
        function save(this)
            save(fullfile(this.out_dir, strcat(stackstr(3), '.mat')), 'this');
        end
        function saveFigures(this, label, s, t)
            saveFigures(this.out_dir, closeFigure=true, prefix=sprintf('%s_%s%s_%i_%i_', stackstr(3), label, this.tags, s, t));
        end
        function physio = task_physio(this, subj, task, bold)
            nt = this.num_frames_to_trim + 1;
            switch char(this.source_physio)
                case 'RV'
                    physio = this.physio_rv(subj, task, bold);
                case 'HRV'
                    physio = this.physio_hrv(subj, task, bold);
                case 'iFV'
                    physio = this.physio_iFV(subj, task);
                    physio = physio(nt:end-nt);
                    physio = physio - this.global_signal(bold);
                case {'nophys', 'none'}
                    physio = ones(size(bold,1), 1);
                    physio = physio(nt:end-nt);
                otherwise
                    physio = [];
            end
        end
        function u = unwrap(~, psi)
            u = unwrap(angle(psi));
        end

        function this = AnalyticSignal(opts)
            %% ANALYTICSIGNAL 
            %  Args:
            %      opts.do_plot_emd logical = false
            %      opts.do_plot_networks logical = false
            %      opts.do_plot_radar logical = false
            %      opts.do_save (logical): save fully populated this to mlraut_AnalyticSignal.mat
            %      opts.hp_thresh (isnumeric): default := 0.00648, Dworetsky; support ~ 2/this.num_frames ~ 0.0019, compared to Ryan's 0.01.
            %      opts.lp_thresh (isnumeric): default := 0.0576, Dworetsky; support ~ 1/2, compared to Ryan's 0.05.
            %      opts.normalization {mustBeTextScalar} = 'normgs'
            %      opts.out_dir (folder): default is pwd.
            %      opts.source_physio {mustBeTextScalar} = 'iFV'
            %      opts.subjects (cell of text): default {'995174'}
            %      opts.tasks (cell of text): default {'rfMRI_REST1_LR','rfMRI_REST1_RL','rfMRI_REST2_LR','rfMRI_REST2_RL'}
            
            arguments
                opts.do_plot_emd logical = false
                opts.do_plot_networks logical = true
                opts.do_plot_radar logical = false
                opts.do_save logical = true
                opts.hp_thresh {mustBeScalarOrEmpty} = 0.009*0.72
                opts.lp_thresh {mustBeScalarOrEmpty} = 0.08*0.72
                opts.normalization {mustBeTextScalar} = ''
                opts.out_dir {mustBeFolder} = pwd
                opts.source_physio {mustBeTextScalar} = 'iFV'
                opts.subjects cell = {}
                opts.tasks cell = {}
            end
            %tasks = {'rfMRI_REST1_7T_AP','rfMRI_REST1_7T_PA' 'rfMRI_REST2_7T_AP','rfMRI_REST2_7T_PA'};
            %tasks = {'tfMRI_MOTOR_LR','tfMRI_MOTOR_RL'};            
            if isempty(opts.subjects)
                opts.subjects = cellfun(@(x) basename(x), ...
                    glob(fullfile(this.root_dir, '99*'))', UniformOutput=false);
            end
            if isempty(opts.tasks)
                opts.tasks = {'rfMRI_REST1_LR','rfMRI_REST1_RL','rfMRI_REST2_LR','rfMRI_REST2_RL'};
            end

            this.normalization = opts.normalization;
            this.do_plot_emd = opts.do_plot_emd;
            this.do_plot_networks = opts.do_plot_networks;
            this.do_plot_radar = opts.do_plot_radar;
            this.do_save = opts.do_save;
            if isnan(opts.hp_thresh)
                this.hp_thresh = 2/this.num_frames;
            else
                this.hp_thresh = opts.hp_thresh;
            end
            if isnan(opts.lp_thresh)
                this.lp_thresh = this.Fs/2*0.999;
            else
                this.lp_thresh = opts.lp_thresh;
            end
            this.out_dir = opts.out_dir;
            this.source_physio = opts.source_physio;
            this.subjects_ = opts.subjects;
            this.tasks_ = opts.tasks;

            this.analytic_signals = complex(nan(this.num_frames, this.num_nodes, this.num_sub, this.num_tasks));           
            this.global_signals = complex(nan(this.num_frames, this.num_sub, this.num_tasks));
            this.HCP_signals.cbm = complex(nan(this.num_frames,this.num_nets,this.num_sub,this.num_tasks));
            this.HCP_signals.ctx = complex(nan(this.num_frames,this.num_nets,this.num_sub,this.num_tasks));
            this.HCP_signals.str = complex(nan(this.num_frames,this.num_nets,this.num_sub,this.num_tasks));
            this.HCP_signals.thal = complex(nan(this.num_frames,this.num_nets,this.num_sub,this.num_tasks));
            this.physio_signals = complex(nan(this.num_frames, this.num_sub, this.num_tasks));

            addpath(genpath(fullfile(this.waves_dir, 'Dependencies', '')));
            addpath(genpath(fullfile(this.waves_dir, 'supporting_files', '')));
        end
    end

    %% PRIVATE

    properties (Access = private)
        subjects_
        tasks_
    end

    methods (Access = private)
        function physio = physio_hrv(this, sub, task, bold)
            %% pulse ox samples <- *_Physio_log.txt, data_(:,3)

            data_ = this.physio_log(sub, task);
            time_vec_bold = this.tr*(1:size(bold,1))';
            time_vec_phys = (0:length(data_)-1)'/this.physFs;
            physio = zeros(size(time_vec_bold));            
            data_(:,3) = zscore(data_(:,3)); % of pulse ox tracing

            idx0 = this.num_frames_to_trim + 1;
            idxf = length(physio) - this.num_frames_to_trim;
            for idx = idx0:idxf
                
                % For HRV, get 6 sec windows
                [~,phys_start] = min(abs(time_vec_phys - (time_vec_bold(idx) - 3)));
                [~,phys_end] = min(abs(time_vec_phys - (time_vec_bold(idx) + 3)));
               
                % For HRV
                [pks,locs] = findpeaks(data_(phys_start:phys_end,3),'minpeakdistance',round(this.physFs/(180/60)));
                             %,'minpeakwidth',400/(1/(200/60))); 
                             % max heart rate = 180 bpm; at 400 Hz, minimum of 100 samples apart
                locs = locs(pks>prctile(data_(phys_start:phys_end,3),60));
                physio(idx) = median(diff(locs),'omitnan')/this.physFs;
            end
        end
        function physio = physio_iFV(this, sub, task)
            iFV = mlraut.IFourthVentricle(this, sub, task);
            physio = call(iFV);
        end
        function physio = physio_rv(this, sub, task, bold)
            %% resp. belt samples <- *_Physio_log.txt, data_(:,2)
            %  Args:
            %      subj (text)
            %      task (text)
            %      bold (numeric)
            %  Returns:
            %      physio (numeric): from <task>_Physio_log.txt

            data_ = this.physio_log(sub, task);
            time_vec_bold = this.tr*(1:size(bold,1))';
            time_vec_phys = (0:length(data_)-1)'/this.physFs;
            physio = zeros(size(time_vec_bold));

            idx0 = this.num_frames_to_trim + 1;
            idxf = length(physio) - this.num_frames_to_trim;
            for idx = idx0:idxf
                
                % For RV, get 6 sec windows
                [~,phys_start] = min(abs(time_vec_phys - (time_vec_bold(idx) - 3)));
                [~,phys_end] = min(abs(time_vec_phys - (time_vec_bold(idx) + 3)));
                physio(idx) = std(data_(phys_start:phys_end,2)); % of resp. belt tracing
            end
        end
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
