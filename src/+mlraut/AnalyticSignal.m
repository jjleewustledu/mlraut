classdef AnalyticSignal < handle & mlraut.HCP
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties
        do_plot_emd
        do_plot_global_physio
        do_plot_networks
        do_plot_radar
        do_save
        do_save_subset
        do_save_ciftis
        do_save_ciftis_of_diffs
        do_save_dynamic

        force_band  % force bandpass to [0.01 0.1] Hz
        force_legacy_butter  
        final_normalization
        frac_ext_physio  % fraction of external physio power
        source_physio
        v_physio  % velocity of physio signal, m/s
        v_physio_iFV  % velocity of physio signal, m/s
    end

    properties (Dependent)
        anatomy_list
        digital_filter
        global_signal
        global_signal_regression  % logical
        hp_thresh  % low freq. bound, Ryan ~ 0.01 Hz
        json
        lp_thresh  % high freq. bound, Ryan ~ 0.05 Hz
        rsn_list
        scale_to_hcp  % adjust norm by time of scanning
        tags  % for filenames
        tags_user

        bold_signal
        physio_angle
        physio_signal
        roi
        source_physio_is_ROI
        source_physio_is_none
    end

    methods %% GET, SET
        function g = get.anatomy_list(~)
            % g = {'ctx', 'str', 'thal', 'cbm'};
            g = {'ctx', 'str', 'thal', 'cbm'};
        end
        function g = get.digital_filter(this)
            g = this.digital_filter_;

        end
        function g = get.global_signal(this)
            g = this.global_signal_;
        end

        function g = get.global_signal_regression(this)
            g = this.global_signal_regression_;
        end

        function g = get.hp_thresh(this)
            N = this.num_frames - this.num_frames_to_trim;
            Nyquist = (this.Fs/2)*(1/N); % Nyquist limited Hz
            if this.force_band
                g = max(0.01, Nyquist);
                return
            end
            if ~isempty(this.hp_thresh_)
                g = max(this.hp_thresh_, Nyquist);
                return
            end
            g = this.hp_thresh_; 
        end

        function g = get.json(this)
            g = this.cohort_data_.json;
        end
        function     set.json(this, s)
            this.cohort_data_.json = s;
        end

        function g = get.lp_thresh(this)
            Nyquist = this.Fs/2 - 1e-6; % Nyquist limited Hz
            if this.force_band
                g = min(0.1, Nyquist);
                return
            end
            if ~isempty(this.lp_thresh_)
                g = min(this.lp_thresh_, Nyquist);
                return
            end
            g = this.lp_thresh_;
        end     

        function g = get.rsn_list(~)
            g = mlraut.NetworkData.NETWORKS_YEO_NAMES;
        end

        function g = get.scale_to_hcp(this)
            if ~isempty(this.scale_to_hcp_)
                g = this.scale_to_hcp_;
                return
            end

            this.scale_to_hcp_ = min(1192, this.max_frames)*0.72/(this.num_frames*this.tr);
            g = this.scale_to_hcp_;
        end

        function g = get.tags(this)
            if isempty(this.final_normalization) && strcmp(this.source_physio, "iFV") && ...
                    ~isempty(this.hp_thresh) && ~isempty(this.lp_thresh)
                % provide legacy compatibility
                g = "";
                return
            end

            g = "proc";
            if ~isempty(this.v_physio)
                g = g + "-v" + strrep(num2str(this.v_physio), ".", "p");
            end
            if ~isempty(this.lp_thresh)
                g = g + "-lp" + strrep(num2str(this.lp_thresh), ".", "p");
            end
            if ~isempty(this.hp_thresh) 
                g = g + "-hp" + strrep(num2str(this.hp_thresh), ".", "p");
            end
            if ~isemptytext(this.final_normalization) && ~contains(this.final_normalization, "none")
                g = g + "-" + this.final_normalization;
            end
            if ~isemptytext(this.source_physio)
                g = g + "-" + this.source_physio;
            end
            if isfinite(this.max_frames)
                g = g + "-maxframes" + num2str(this.max_frames);
            end
            if ~isemptytext(this.tags_user_) 
                g = g + "-" + this.tags_user_;
            end
        end

        function g = get.tags_user(this)
            g = this.tags_user_;
        end        
        function set.tags_user(this, s)
            this.tags_user_ = s;
        end

        function g = get.bold_signal(this)
            g = this.bold_signal_;
        end

        function g = get.physio_angle(this)
            if isempty(this.physio_signal)
                g = [];
                return
            end
            if isempty(this.physio_angle_)
               this.physio_angle_ = angle(mean(this.physio_signal, 2));
            end
            g = this.physio_angle_;
        end

        function g = get.physio_signal(this)
            g = this.physio_signal_;
        end

        function g = get.roi(this)
            g = this.roi_;
        end

        function g = get.source_physio_is_ROI(this)
            g = ~contains(this.source_physio, ["RV", "HRV", "no-physio", "nophys", "none"]);
        end

        function g = get.source_physio_is_none(this)
            g = contains(this.source_physio, ["no-physio", "nophys", "none"]);
        end
    end
    
    methods

        %% helpers for buillding

        function psi = average_network_signal(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric}
                opts.network_type {mustBeText} = "cortical"
            end

            if contains(opts.network_type, "cerebell", IgnoreCase=true)
                dat = mlraut.CerebellarData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if contains(opts.network_type, "cort", IgnoreCase=true)
                dat = mlraut.CorticalData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if contains(opts.network_type, "striat", IgnoreCase=true)
                dat = mlraut.StriatalData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if contains(opts.network_type, "thalam", IgnoreCase=true)
                dat = mlraut.ThalamicData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            error("mlraut:ValueError", stackstr())
        end

        function dat1 = build_band_passed(this, dat)
            %% Implements designfilt, caching results
            %  web(fullfile(docroot, 'signal/ug/practical-introduction-to-digital-filtering.html?browser=F1help'))

            if isempty(this.lp_thresh) && isempty(this.hp_thresh)
                dat1 = dat;
                return
            end

            if this.force_legacy_butter
                dat1 = this.build_band_passed_butter(dat);
                return
            end

            if isempty(this.digital_filter_)
                if isempty(this.lp_thresh) && ~isempty(isempty(this.hp_thresh))
                    this.digital_filter_ = designfilt("highpassiir", ...
                        FilterOrder=8, ...
                        HalfPowerFrequency=this.hp_thresh, ...
                        SampleRate=this.Fs);
                elseif ~isempty(this.lp_thresh) && isempty(this.hp_thresh)
                    this.digital_filter_ = designfilt("lowpassiir", ...
                        FilterOrder=8, ...
                        HalfPowerFrequency=this.lp_thresh, ...
                        SampleRate=this.Fs);
                else
                    this.digital_filter_ = designfilt("bandpassiir", ...
                        FilterOrder=8, ...
                        HalfPowerFrequency1=this.hp_thresh, HalfPowerFrequency2=this.lp_thresh, ...
                        SampleRate=this.Fs);
                end
            end

            dat1 = filtfilt(this.digital_filter_, double(dat));  % zero-phase digital filtering; https://www.mathworks.com/help/releases/R2024b/signal/ref/filtfilt.html
            if isa(dat, 'single')
                dat1 = single(dat1);
            end
            if isa(dat, 'double')
                dat1 = double(dat1);
            end
        end
        
        function dat1 = build_band_passed_butter(this, dat)
            %% Implements butter:  web(fullfile(docroot, 'signal/ref/butter.html?browser=F1help#bucsfmj')) 
            %  with configuration matched to Ryan's.  
            %  See also web(fullfile(docroot, 'signal/ug/practical-introduction-to-digital-filtering.html')) .
            %  Returns:
            %      dat1 same num. type as dat
            %      dat1 ~ ones() if dat ~ zeros() to accomodate no no physio
            %      sos, for visualization with `freqz(sos,[],this.Fs)`

            if all(dat == 0)
                dat1 = ones(size(dat));
                return
            end
            if isempty(this.lp_thresh) && isempty(this.hp_thresh)
                dat1 = dat;
                return
            end
            [z,p,k] = butter(2, [this.hp_thresh, this.lp_thresh - eps('single')]/(this.Fs/2)); % digital Wn in [0, 1]
            [sos,g] = zp2sos(z, p, k);
            this.digital_filter_ = sos;
            dat1 = filtfilt(sos, g, double(dat));
            if isa(dat, 'single')
                dat1 = single(dat1);
            end
            if isa(dat, 'double')
                dat1 = double(dat1);
            end
        end

        function psi = build_centered(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal %#ok<INUSA>
                psi {mustBeNumeric,mustBeNonempty}
                opts.reference {mustBeNumeric} = psi                
            end

            if all(psi == 0)
                return
            end

            psi = psi - mean(opts.reference, 'all', 'omitnan');
        end

        function psi = build_centered_and_rescaled(this, psi, varargin)
            %% Mimics z-score of |psi(t,x)> using mean and mad.

            psi = this.build_centered(psi, varargin{:});
            psi = this.build_rescaled(psi, varargin{:});
        end
        
        function as = build_final_normalization(this, as)
            %% provides final normalization by max(abs()) for more interpretable visualization at group level;
            %  as ~ Nt x Nxyz

            switch convertStringsToChars(this.final_normalization)
                case 'normt'
                    % allowing fluctuations in xyz, equalize t
                    as = as ./ this.build_norm(as, dim=1);
                case 'normxyz'
                    % allowing fluctuations in t, equalize xyz
                    as = as ./ this.build_norm(as, dim=2);
                case 'normxyzt'
                    % allowing fluctuations in xyz & t
                    as = as / this.build_norm(as, dim="all");
                otherwise
                    return
            end
        end

        function [gs,beta] = build_global_signal_for(this, sig)
            %% global_signal := mean(sig, "space"), then formatted for greyordinates or 4D voxels
            %  Args:
            %    this mlraut.AnalyticSignal
            %    sig double = ones(this.num_frames, 1)            

            arguments
                this mlraut.AnalyticSignal
                sig double = ones(this.num_frames, 1)
            end

            % task niigz in 4D, reshaped to 2D 
            niigz = this.task_niigz();
            sz = size(niigz);
            assert(sz(4) == this.num_frames)
            niigz = reshape(niigz, [sz(1)*sz(2)*sz(3), sz(4)]);

            % mask ~ 3D task signal reference; reshaped to 2D
            msk = this.task_signal_mask();
            msk = reshape(msk, [sz(1)*sz(2)*sz(3), 1]);

            % img ~ task niigz masked; then mean
            img_g = double(niigz);
            img_g = img_g(logical(msk), :);
            img_g = mean(img_g, 1);

            % format for greyordinates
            this.global_signal_ = ascol(img_g);
            this.global_signal_beta_ = 1;

            if isnumeric(sig)
                assert(size(sig, 1) == this.num_frames)
                gs = this.global_signal_;  % col
                beta = this.global_signal_beta_;  % row
                return
            end
            if isa(sig, "mlfourd.ImagingContext2")
                sz = size(sig);
                assert(sz(4) == this.num_frames)
                sig = reshape(sig, [sz(1)*sz(2)*sz(3), sz(4)]);

                msk = this.task_signal_mask();
                msk = reshape(msk, [sz(1)*sz(2)*sz(3), 1]);

                img_g = double(sig);
                img_g(logical(msk), :) = repmat(asrow(this.global_signal_), [sum(logical(msk)), 1]);
                img_g = reshape(img_g, [sz(1), sz(2), sz(3), sz(4)]);
  
                img_b = double(sig);
                img_b(logical(msk), :) = this.global_signal_beta_ * ones(sum(logical(msk), sz(4)));
                img_b = reshape(img_b, [sz(1), sz(2), sz(3), sz(4)]);

                gs = sig.selectImagingTool(img=img_g);
                gs.fileprefix = "global-signal";
                beta = sig.selectImagingTool(img=img_b);
                beta.fileprefix = "global-signal-beta";
                return
            end
            error("mlraut:TypeError", stackstr())
        end

        function psi = build_global_signal_regressed(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric,mustBeNonempty}
                opts.is_physio logical = false
            end

            if ~this.global_signal_regression
                return
            end
            if opts.is_physio && ~this.source_physio_is_ROI
                return
            end
            if all(psi == 0)
                return
            end

            psi = psi - this.build_global_signal_for(psi);
        end

        function n = build_norm(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric}
                opts.dim = "all" 
            end
            n = mad(abs(psi), 0, opts.dim);  % mean abs. dev.
        end

        function psi = build_rescaled(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal 
                psi {mustBeNumeric,mustBeNonempty}
                opts.reference {mustBeNumeric} = psi
            end

            if all(psi == 0)
                return
            end
            
            d = this.build_norm(opts.reference);
            psi = psi./d;
        end

        function p = mix_physio(this, p_0, p_1)
            %% mix phyio signals:  p := (1 - f)*p_0 + f*p_1, f ~ this.frac_ext_physio, weighted by norms

            f = this.frac_ext_physio;
            if f < eps
                p = p_0;
                return
            end
            if f > 1 - eps
                p = p_1;
                return
            end

            n_0 = this.build_norm(p_0);  % scalars
            n_1 = this.build_norm(p_1);

            g_0 = 1/n_1 + 2*(1 - 1/n_1)*f;  % scalars
            g_1 = 2 - 1/n_0 - 2*(1 - 1/n_0)*f;

            p = (1 - f)*g_0*n_1*p_0 + f*g_1*n_0*p_1;  % mat -> mat
        end

        function b = omit_late_frames(this, b)
            %% Keep frames 1:this.max_frames, following use of trim_frames() to remove this.num_frames_to_trim
            %  from start and end of frames, for purposes of omitting brain/cognitive responses to start and conclusion 
            %  of the scanning session.            

            if isnumeric(b)
                bound = min(this.max_frames, size(b, 1));
                b = b(1:bound, :);
                return
            end
            if isa(b, "mlfourd.ImagingContext2")
                bound = min(this.max_frames, size(b, 4));
                img = double(b);
                img = img(:,:,:,1:bound);
                b.selectImagingTool(img=img);
                j = b.json_metadata;
                j.timesMid = j.timesMid(1:bound);
                b.addJsonMetadata(j);
                return
            end
            error("mlraut:TypeError", stackstr())
        end

        %% plotting

        function fit_power_law(this, opts)
            %% "In matlab, how best should I examine the power spectrum of a time-series for power law behavior?" 
            %  https://claude.ai/chat/7c0ba283-3bc7-4938-9dec-8acd7bd25e7a
            %  Args:
            %    this mlraut.AnalyticSignal
            %    opts.t double = []
            %    opts.x double = []
            %    opts.title = stackstr(use_spaces=true)

            arguments
                this mlraut.AnalyticSignal
                opts.t double = []
                opts.x double = []
                opts.title = ""
            end
            if isempty(opts.t)
                tf = this.num_frames*this.tr;
                opts.t = 0:this.tr:tf;
            end
            t = opts.t;
            if isempty(opts.x)
                opts.x = this.build_global_signal_for();
            end
            x = opts.x;

            % Compute the Fourier transform
            N = length(x);
            X = fft(x);

            % Compute the power spectrum
            P = abs(X).^2 / N;

            % Compute the corresponding frequencies
            fs = 1 / (t(2) - t(1));  % Sampling frequency
            f = (0:N-1)*(fs/N);      % Frequency range

            % Use only the first half of the spectrum (it's symmetric)
            P = P(1:floor(N/2)+1);
            f = f(1:floor(N/2)+1);

            % Plot the power spectrum on a log-log scale
            figure;
            civ = cividis;
            loglog(f, P, LineWidth=2, Color=civ(1,:));
            xlabel('Frequency (Hz)');
            ylabel('Power');
            title(opts.title);
            grid on;

            % Optional: Fit a power law
            % Select a range for fitting (adjust as needed)
            fit_range = f > this.hp_thresh & f < this.lp_thresh;

            % Perform linear regression on log-log data
            p = polyfit(log10(f(fit_range)), log10(P(fit_range)), 1);

            % Add the fit line to the plot
            hold on;
            loglog(f(fit_range), 10.^(polyval(p, log10(f(fit_range)))), 'm--', 'LineWidth', 2);
            legend('BOLD', sprintf('power law exponent = %.2f', p(1)), Location="southeast");
            fontsize(scale=2)

            % Display the slope (which is the power law exponent)
            fprintf('Power law exponent: %.2f\n', p(1));
        end

        function plot3(this, opts)
            arguments
                this mlraut.AnalyticSignal
                opts.t double = []
                opts.z double = []
                opts.num_frames double = []
                opts.title {mustBeTextScalar} = ""
                opts.symbol {mustBeTextScalar} = "\psi"
            end
            if isempty(opts.num_frames)
                opts.num_frames = this.num_frames;  % ceil(300/this.tr);
            end
            if isempty(opts.t)
                tf = (opts.num_frames - 1)*this.tr;
                opts.t = 0:this.tr:tf;
            end
            t = opts.t;
            if isempty(opts.z)

                % select cortical default mode
                ctx = this.average_network_signal(this.task_dtseries(), network_type="cortical");
                select_rsn = contains(mlraut.NetworkData.NETWORKS_YEO_NAMES, "default mode");
                bold_ = ctx(:, select_rsn);

                % aufbau Hilbert transform
                bold_ = ...
                    hilbert( ...
                    this.build_band_passed( ...
                    this.build_centered_and_rescaled( ...
                    this.build_global_signal_regressed(bold_))));
                bold_ = ...                    
                    this.build_final_normalization( ...
                        bold_(1:opts.num_frames, :));

                opts.z = bold_;
            end
            z = opts.z;

            % 3D Line Plot
            figure('Position', [100, 100, 1200, 600]);
            civ = cividis;
            plot3(t, real(z), imag(z), LineWidth=2, Color=civ(1,:));
            xlabel("time / s");
            ylabel(sprintf('Re %s(t)', opts.symbol));
            zlabel(sprintf('Im %s(t)', opts.symbol));
            title(opts.title);
            grid on;
            fontsize(scale=2)
            title(opts.title);

            % Stretch the time axis
            %%current_aspect = pbaspect;
            pbaspect([4 1 1]);  % Stretch time axis (x-axis) by a factor of 3

            % Add a 2D projection onto the complex plane
            figure;
            scatter(real(z), imag(z), [], t, 'filled', 'o', MarkerFaceAlpha=0.618);
            ylabel(sprintf('Re %s(t)', opts.symbol));
            ylabel(sprintf('Im %s(t)', opts.symbol));
            title("");
            axis equal;
            colorbar;
            colormap('cividis');
            c = colorbar;
            c.Label.String = 'time / s';
            fontsize(scale=2)
            title(opts.title);
        end

        function plot_emd(this, varargin)
            this.plotting_.plot_emd(varargin{:});
        end

        function h1 = plot_global_physio(this, varargin)
            h1 = this.plotting_.plot_global_physio(varargin{:});
        end

        function plot_regions(this, varargin)
            this.plotting_.plot_regions(varargin{:});
        end

        function [h1,h3] = plot_networks(this, varargin)
            [h1,h3] = this.plotting_.plot_networks(varargin{:});
        end

        function [h1,h3] = plot_networks_dots(this, varargin)
            [h1,h3] = this.plotting_.plot_networks_dots(varargin{:});
        end

        function [h,h1,h2] = plot_radar(this, varargin)
            [h,h1,h2] = this.plotting_.plot_radar(varargin{:});
        end

        function [h,h1] = plot_timeseries_qc(this, varargin)
            [h,h1] = this.plotting_.plot_timeseries_qc(varargin{:});
        end
        
        %% helpers for BOLD

        function mat = task_dtseries(this, varargin)
            %% supports interface 

            mat = this.task_dtseries_simple(varargin{:});
        end

        function mat = task_dtseries_simple(this, sub, task, opts)
            %  Args:
            %      this mlraut.AnalyticSignal
            %      opts.max_frames double = Inf
            %      opts.subjects cell {mustBeText} = {}
            %      opts.tasks cell {mustBeText} = {}
            %      opts.network_type {mustBeText} = ""
            %  Returns:
            %      mat (numeric):  time x grayordinate from BOLDData

            arguments
                this mlraut.AnalyticSignal
                sub {mustBeTextScalar} = this.current_subject
                task {mustBeTextScalar} = this.current_task
                opts.network_type {mustBeText} = ""
            end

            this.current_subject = sub;
            this.current_task = task;

            mat = this.bold_data_.task_dtseries();
            mat = this.trim_frames(mat);
            mat = this.omit_late_frames(mat);
            mat = single(mat);

            if ~isemptytext(opts.network_type)
                mat = this.average_network_signal(mat, network_type=opts.network_type);
            end
        end

        function ic = task_niigz(this)
            ic = task_niigz@mlraut.HCP(this);
            ic = this.trim_frames(ic);
            ic = this.omit_late_frames(ic);
            ic.ensureSingle();
            ic.fileprefix = stackstr(use_dashes=true);
        end

        function [physio,physio_vec] = task_physio(this, opts)
            %  Returns:
            %      physio numeric Nt x 1
            %      physio_0 numeric Nt x 1
            %  Throws:
            %      mlraut:ValueError if this.source_physio not supported

            arguments
                this mlraut.AnalyticSignal
                opts.roi = this.roi
                opts.flipLR logical = false
                opts.source_physio {mustBeText} = this.source_physio
                opts.reference {mustBeNumeric} = []
            end

            bold = this.task_niigz();
            switch convertStringsToChars(this.source_physio)
                case 'RV'
                    RV = mlraut.PhysioRV(this, bold);
                    physio_vec_ = RV.call();
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_)));
                    physio = ones(size(opts.reference)).*physio_vec;
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")  
                case 'HRV'
                    HRV = mlraut.PhysioHRV(this, bold);
                    physio_vec_ = HRV.call();
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_)));
                    physio = ones(size(opts.reference)).*physio_vec;
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")  
                case 'iFV'  % propagated
                    iFV = mlraut.IFourthVentricle(this, bold);
                    ifv_pos = this.twistors_.center_of_mass_position(iFV.ifv_mask);
                    physio_vec_ = iFV.call();
                    physio_vec_gsr_ = ...
                        this.build_global_signal_regressed(physio_vec_, is_physio=true);
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_gsr_)));
                    physio = this.twistors_.propagate_physio( ...
                        opts.reference, physio_vec, ...
                        physio_pos=ifv_pos, ...
                        v=this.v_physio);
                    assert(all(isfinite(physio), "all"), "likely that Twistors.propagate_physio is faulty")  
                case 'ROI'  % propagated, superposed with iFV
                    iFV = mlraut.IFourthVentricle(this, bold);
                    ifv_pos = this.twistors_.center_of_mass_position(iFV.ifv_mask);
                    physio_vec_0_ = iFV.call();
                    physio_vec_0_gsr_ = ...
                        this.build_global_signal_regressed(physio_vec_0_, is_physio=true);
                    physio_vec_0 = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_0_gsr_)));
                    physio_0 = this.twistors_.propagate_physio( ...
                        opts.reference, physio_vec_0, ...
                        physio_pos=ifv_pos, ...
                        v=0.1);

                    pROI = mlraut.PhysioRoi(this, bold, ...
                        from_imaging_context=opts.roi, flipLR=opts.flipLR);
                    proi_pos = this.twistors_.center_of_mass_position(pROI.roi_mask);
                    physio_vec_1_ = pROI.call();
                    physio_vec_1_gsr_ = ...
                        this.build_global_signal_regressed(physio_vec_1_, is_physio=true);
                    physio_vec_1 = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_1_gsr_)));
                    physio_1 = this.twistors_.propagate_physio( ...
                        opts.reference, physio_vec_1, ...
                        physio_pos=proi_pos, ...
                        v=this.v_physio);

                    physio_vec = this.mix_physio(physio_vec_0, physio_vec_1);  % superposition of physio signals
                    physio = this.mix_physio(physio_0, physio_1);  % superposition of physio signals
                    assert(all(isfinite(physio), "all"), "likely that Twistors.propagate_physio is faulty")  
                case {'no-physio', 'nophys', 'none'}
                    physio_vec = ones(size(opts.reference, 1), 1);
                    physio = ones(size(opts.reference)).*physio_vec;
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")  
                otherwise  % other wmparc regions, propagated
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    n = wmparc.label_to_num(convertStringsToChars(this.source_physio));
                    assert(~all(n == 0), stackstr())
                    pROI = mlraut.PhysioRoi(this, bold, ...
                        from_wmparc_indices=n, flipLR=opts.flipLR);
                    proi_pos = this.twistors_.center_of_mass_position(pROI.roi_mask);
                    physio_vec_ = pROI.call();
                    physio_vec_gsr_ = ...
                        this.build_global_signal_regressed(physio_vec_, is_physio=true);
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_gsr_)));
                    physio = this.twistors_.propagate_physio( ...
                        opts.reference, physio_vec, ...
                        physio_pos=proi_pos, ...
                        v=this.v_physio);
                    assert(all(isfinite(physio), "all"), "likely that Twistors.propagate_physio is faulty")  
            end
            physio_vec = single(physio_vec);
            physio = single(physio);
            assert(~isempty(physio))
        end

        function ic = task_signal_mask(this)
            % if ~isempty(this.task_signal_mask_)
            %     ic = this.task_signal_mask_;
            %     return
            % end

            ic = this.task_signal_reference();
            ic = ic.binarized();
            
            ic1 = mlfourd.ImagingContext2(this.wmparc_fqfn);
            ic1 = ic1.binarized();
            % ic1 = ic1.blurred(6);
            % ic1 = ic1.thresh(0.1);
            % ic1 = ic1.binarized();
            if ~isempty(getenv("DEBUG"))
                ic1.view_qc(ic);
            end

            % mask should not have greater coverage than blurred binarized wmparc
            if dipsum(ic) > dipsum(ic1)
                ic = ic1;
            end
            ic.ensureSingle();
            this.task_signal_mask_ = ic;
        end

        function ic = task_signal_reference(this)
            ic = task_signal_reference@mlraut.HCP(this);
            ic.ensureSingle();
        end

        %% misc. helpers

        function psi = X(this, varargin)
            psi = this.twistors_.X(varargin{:});
        end

        function psi = Y(this, varargin)
            psi = this.twistors_.Y(varargin{:});
        end

        function psi = Z(this, varargin)
            psi = this.twistors_.Z(varargin{:});
        end

        function psi = T(this, varargin)
            psi = this.twistors_.T(varargin{:});
        end

        function psi = angle(this, varargin)
            psi = this.twistors_.angle(varargin{:});
        end

        function psi = unwrap(this, varargin)
            psi = this.twistors_.unwrap(varargin{:});
        end

        function tseries = trim_frames(this, tseries)
            nt = this.num_frames_to_trim + 1;
            if isnumeric(tseries)
                tseries = tseries(nt:end,:);
                return
            end
            if isa(tseries, "mlfourd.ImagingContext2")
                img = double(tseries);
                img = img(:,:,:,nt:end);
                tseries.selectImagingTool(img=img);
                j = tseries.json_metadata;
                j.timesMid = j.timesMid(nt:end);
                tseries.addJsonMetadata(j);
                return
            end
            error("mlraut:TypeError", stackstr())
        end

        function c = write_cifti(this, varargin)
            c = this.cifti_.write_cifti(varargin{:});
        end

        function [c,c1] = write_ciftis(this, varargin)
            [c,c1] = this.cifti_.write_ciftis(varargin{:});
        end

        function ic = write_nii(this, varargin)
            ic = this.cifti_.write_nii(varargin{:});
        end

        %%

        function this = AnalyticSignal(opts)
            %% ANALYTICSIGNAL 
            %  Args:
            %      opts.do_7T logical = false
            %      opts.do_resting logical = true
            %      opts.do_task logical = false
            %      opts.do_plot_global_physio logical = true
            %      opts.do_plot_networks logical = true
            %      opts.do_plot_radar logical = true
            %      opts.do_save logical = true : save fully populated this to mlraut_AnalyticSignal.mat
            %      opts.do_save_subset logical = false : save only subset of this to decrease storage
            %      opts.do_save_ciftis logical = true: save ciftis of {abs,angle} of analytic_signal.
            %      opts.do_save_ciftis_of_diffs logical = true: save ciftis of {abs,angle} of analytic_signal, diff from bold.
            %      opts.do_save_dynamic logical = false; save large dynamic dtseries
            %      opts.final_normalization {mustBeTextScalar} = 'normxyzt': also: 'normt' | 'normxyz' | ''
            %      opts.force_band logical = true: force bandpass to Nyquist limits of available data
            %      opts.force_legacy_butter logical = false: 
            %      opts.frac_ext_physio double = 0.5 : fraction of external physio signal power
            %      opts.hp_thresh {mustBeScalarOrEmpty} : default := 0.009*0.72, Dworetsky; support ~ 2/this.num_frames ~ 0.0019, compared to Ryan's 0.01.
            %                                             nan =: 2/(this.num_frames - this.num_frames_to_trim).
            %      opts.lp_thresh {mustBeScalarOrEmpty} : default := 0.08*0.72, Dworetsky; support ~ 1/(2*this.tr), compared to Ryan's 0.05.
            %                                             nan =: 1/2
            %      opts.max_frames {mustBeScalarOrEmpty} = nan: try 158 for assessing GBM rsfMRI
            %      opts.out_dir {mustBeFolder} = pwd
            %      opts.roi = []:  e.g. fqfn;
            %                      ImagingContext2 for "WT_on_T1w", "CE_on_T1w", for files found in sub-*/MNINonLinear; 
            %                      double row_vec for mlraut.PhysioRoi(from_wmparc_indices=row_vec)
            %                      used with this.task_physio()
            %      opts.scale_to_hcp {mustBeScalar,mustBePositive} = 1: scaling factor
            %      opts.source_physio {mustBeTextScalar} = 'iFV'
            %      opts.v_physio double = 0.1
            %      opts.v_physio_iFV double = 50
            %      opts.global_signal_regression logical = true
            %      opts.subjects cell {mustBeText} = {}
            %      opts.tags {mustBeTextScalar} = ""
            %      opts.tasks cell {mustBeText} = {}
            
            arguments
                opts.do_7T logical = false
                opts.do_resting logical = true
                opts.do_task logical = false
                opts.do_plot_emd logical = false
                opts.do_plot_global_physio logical = false
                opts.do_plot_networks logical = false
                opts.do_plot_radar logical = false
                opts.do_save logical = false
                opts.do_save_subset logical = false
                opts.do_save_ciftis logical = false
                opts.do_save_ciftis_of_diffs logical = false
                opts.do_save_dynamic logical = false
                opts.final_normalization {mustBeTextScalar} = "normxyzt"
                opts.force_band logical = false
                opts.force_legacy_butter logical = false
                opts.frac_ext_physio double = 0.5
                opts.global_signal_regression logical = true
                opts.hp_thresh {mustBeScalarOrEmpty} = 0.01
                opts.lp_thresh {mustBeScalarOrEmpty} = 0.1
                opts.max_frames double = Inf
                opts.out_dir {mustBeTextScalar} = ""
                opts.plot_range double = []
                opts.roi = []
                opts.scale_to_hcp double {mustBePositive} = 1
                opts.source_physio = "iFV"
                opts.v_physio double = 50
                opts.v_physio_iFV double = 50
                opts.subjects = {}
                opts.tags {mustBeTextScalar} = ""
                opts.tasks = {}
            end

            this = this@mlraut.HCP(max_frames=opts.max_frames, subjects=opts.subjects, tasks=opts.tasks)

            addpath(genpath(fullfile(this.waves_dir, 'Dependencies', '-end')));
            addpath(genpath(fullfile(this.waves_dir, 'supporting_files', '')));
            this.cifti_ = mlraut.Cifti(this);
            this.plotting_ = mlraut.Plotting(this, plot_range=opts.plot_range);

            this.do_7T = opts.do_7T;
            this.do_resting = opts.do_resting;
            this.do_task = opts.do_task;
            this.do_plot_emd = opts.do_plot_emd;
            this.do_plot_global_physio = opts.do_plot_global_physio;
            this.do_plot_networks = opts.do_plot_networks;
            this.do_plot_radar = opts.do_plot_radar;
            this.do_save = opts.do_save;
            this.do_save_subset = opts.do_save_subset;
            this.do_save_ciftis = opts.do_save_ciftis;
            this.do_save_ciftis_of_diffs = opts.do_save_ciftis_of_diffs;
            this.do_save_dynamic = opts.do_save_dynamic;

            this.force_band = opts.force_band;
            this.force_legacy_butter = opts.force_legacy_butter;
            this.frac_ext_physio = opts.frac_ext_physio;
            this.global_signal_regression_ = opts.global_signal_regression;
            this.hp_thresh_ = opts.hp_thresh;
            this.lp_thresh_ = opts.lp_thresh;
            this.max_frames = opts.max_frames;
            this.final_normalization = opts.final_normalization;
            this.cohort_data_.out_dir = opts.out_dir;
            this.scale_to_hcp_ = opts.scale_to_hcp;
            this.source_physio = opts.source_physio;
            this.v_physio = opts.v_physio;
            this.v_physio_iFV = opts.v_physio_iFV;
            this.tags_user_ = opts.tags;

            this.build_roi(opts.roi);

            this.twistors_ = mlraut.Twistors(this);
        end
    end

    %% PROTECTED

    properties (Access = protected)
        cifti_
        digital_filter_
        hp_thresh_
        lp_thresh_
        plotting_
        scale_to_hcp_
        tags_user_
        task_signal_mask_

        bold_signal_
        global_signal_
        global_signal_beta_
        global_signal_regression_
        physio_angle_
        physio_signal_
        roi_
        twistors_
    end

    methods (Access = protected)
        function that = copyElement(this)
            that = copyElement@matlab.mixin.Copyable(this);
            if ~isempty(this.cifti_)
                that.cifti_ = copy(this.cifti_); end
            if ~isempty(this.plotting_)
                that.plotting_ = copy(this.plotting_); end
            if ~isempty(this.task_signal_mask_)
                that.task_signal_mask_ = copy(this.task_signal_mask_); end
            if ~isempty(this.roi_)
                that.roi_ = copy(this.roi_); end
            if ~isempty(this.twistors_)
                that.twistors_ = copy(this.twistors_); end
        end
    end

    %% PRIVATE

    methods (Access = private)
        function this = build_roi(this, roi)
            arguments
                this mlraut.AnalyticSignal
                roi = []
            end
            if isempty(roi)
                return
            end
            
            this.source_physio = "ROI";
            if isa(roi, "mlfourd.ImagingContext2")
                this.roi_ = copy(roi);
                return
            end
            if istext(roi) && isfile(roi)
                this.roi_ = mlfourd.ImagingContext2(roi);
                return
            end
            if isnumeric(roi) && ismatrix(roi)
                pr = mlraut.PhysioRoi(this, this.task_niigz, from_wmparc_indices=roi);
                this.roi_ = pr.roi_mask;
                return
            end
            if isnumeric(roi) && ~ismatrix(roi)
                this.roi_ = mlfourd.ImagingContext2(roi);
                return
            end
            error("mlraut:ValueError", stackstr())
        end
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
